{"0": {
    "doc": "Chapter 01",
    "title": "Chapter 1Force and moment equilibria",
    "content": "1.1 Statics, rigid bodies and force systems . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=f4af2ded-cd2b-4e10-adf4-ac720118d222 . 1.2 Force couples and moments . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=01a89ffb-ca4e-434d-8368-ac72011bb5bb . ",
    "url": "http://localhost:4000/_lecture/chapter01.html#x1-10001",
    "relUrl": "/_lecture/chapter01.html#x1-10001"
  },"1": {
    "doc": "Chapter 01",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter01.html#x1-40001.2",
    "relUrl": "/_lecture/chapter01.html#x1-40001.2"
  },"2": {
    "doc": "Chapter 01",
    "title": "Chapter 01",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter01.html",
    "relUrl": "/_lecture/chapter01.html"
  },"3": {
    "doc": "Chapter 02",
    "title": "Chapter 2Bearings",
    "content": "2.1 Bearings and degrees of freedom . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=d016adde-d3c6-44e0-8d29-ac720113b2bb . 2.2 Free body diagrams . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=55e9b88e-9101-4af7-8ba5-ac720113b2e3 . ",
    "url": "http://localhost:4000/_lecture/chapter02.html#x1-10002",
    "relUrl": "/_lecture/chapter02.html#x1-10002"
  },"4": {
    "doc": "Chapter 02",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter02.html#x1-40002.2",
    "relUrl": "/_lecture/chapter02.html#x1-40002.2"
  },"5": {
    "doc": "Chapter 02",
    "title": "Chapter 02",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter02.html",
    "relUrl": "/_lecture/chapter02.html"
  },"6": {
    "doc": "Chapter 03",
    "title": "Chapter 3Internal forces",
    "content": "3.1 Internal force variables . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=e8a59939-831f-4c0c-bc84-ac720113b31d . 3.2 Distributed loads . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=716dd142-5797-4567-a3e1-ac720113b35a . ",
    "url": "http://localhost:4000/_lecture/chapter03.html#x1-10003",
    "relUrl": "/_lecture/chapter03.html#x1-10003"
  },"7": {
    "doc": "Chapter 03",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter03.html#x1-40003.2",
    "relUrl": "/_lecture/chapter03.html#x1-40003.2"
  },"8": {
    "doc": "Chapter 03",
    "title": "Chapter 03",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter03.html",
    "relUrl": "/_lecture/chapter03.html"
  },"9": {
    "doc": "Chapter 04",
    "title": "Chapter 4Elastostatic equilibrium",
    "content": "4.1 Stress and static equilibrium . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=c3d56bf8-3178-43ac-8c58-ac720115ef26 . 4.1.1 Small strain theory . We will treat elasticity exclusively in the limit of small or infinitesimal strains where all equations are linear. The generalization of this “small strain” theory is “finite strain” elasticity. Note that linear elasticity is a classical field theory, this means all quantities typically depend continuously on positions \\(\\v{r}\\). Those quantities are called fields. The central quantities of small strain elasticity are the (Cauchy) stress field \\(\\t{\\sigma }(\\v{r})\\) and the displacement field \\(\\v{u}(\\v{r})\\). Given a material point has moved from position \\(\\v{r}\\) to \\(\\v{r}^\\prime \\), the displacement field is \\(\\v{u}(\\v{r})=\\v{r}^\\prime -\\v{r}\\). The stress \\(\\t{\\sigma }\\) is a tensor that transforms an area (vector) \\(\\v{A}\\) into a force vector \\(\\v{F}\\), \\(\\v{F}=\\t{\\sigma }\\cdot \\v{A}\\). Note that the direction of the area vector points outwards on that area. Force equilibrium . We will now consider the equilibrium of forces inside a solid body. Specifically, we regard a small volume element inside this body. For simplicity, we remain in a two-dimensional picture but generalization to three dimensions is straightforward. Figure 4.1a shows a sketch of some body with the (in two-dimensional areal) volume element highlighted in red. If the size of the element \\(\\Delta x\\times \\Delta y \\times \\Delta z\\) is small enough, then the forces on opposite sites of the elements must balance. We here denote the forces on the faces perpendicular to the \\(x\\)-direction by \\(\\v{X}\\), the forces on the \\(y\\)-faces by \\(\\v{Y}\\) and the forces on the \\(z\\)-faces by \\(\\v{Z}\\) (see Fig. 4.1b, \\(z\\)-direction not shown). If we know the areas, we can get the forces from the stress tensor \\(\\t{\\sigma }\\) (that converts areas into forces), specifically \\begin{align} \\label{eqn:forceX} \\v{X} &amp;= \\begin{pmatrix} \\sigma _{xx} \\Delta y \\Delta z \\\\ \\sigma _{yx} \\Delta y \\Delta z \\\\ \\sigma _{zx} \\Delta y \\Delta z \\\\ \\end{pmatrix} \\\\ \\label{eqn:forceY} \\v{Y} &amp;= \\begin{pmatrix} \\sigma _{xy} \\Delta x \\Delta z \\\\ \\sigma _{yy} \\Delta x \\Delta z \\\\ \\sigma _{zy} \\Delta x \\Delta z \\\\ \\end{pmatrix} \\\\ \\label{eqn:forceZ} \\v{Z} &amp;= \\begin{pmatrix} \\sigma _{xz} \\Delta x \\Delta y \\\\ \\sigma _{yz} \\Delta x \\Delta y \\\\ \\sigma _{zz} \\Delta x \\Delta y \\\\ \\end{pmatrix}. \\end{align} . Note that \\(\\v{X}\\), \\(\\v{Y}\\), \\(\\v{Z}\\) and \\(\\t{\\sigma }\\) are field; they explicitly depend on position \\(\\v{r}\\) within the body. Figure 4.1:: Force equilibrium in a small volume element inside a solid body. For a volume element located at position \\(\\v{r}=(x,y,z)\\), force equilibrium inside the element can be expressed as \\begin{equation} \\label{eqn:forceeq} \\begin{split} \\v{X}(x+\\Delta x, y, z) - \\v{X}(x, y, z) &amp;+ \\v{Y}(x, y+\\Delta y, z) - \\v{Y}(x, y, z) \\\\ &amp;+ \\v{Z}(x, y, z+\\Delta z) - \\v{Z}(x, y, z) = \\v{F}(x,y,z) \\end{split} \\end{equation} where \\(\\v{F}(x,y,z)\\) is an external force, often called the body force, acting on the volume element. We can insert Eqs. \\eqref{eqn:forceX}, \\eqref{eqn:forceY} and \\eqref{eqn:forceZ} and divide by the volume of the element \\(\\Delta x \\Delta y \\Delta z\\) to obtain \\begin{equation} \\begin{split} \\frac{\\sigma _{xx}(x+\\Delta x,y,z)-\\sigma _{xx}(x, y, z)}{\\Delta x} &amp;+ \\frac{\\sigma _{xy}(x,y+\\Delta y,z)-\\sigma _{xy}(x, y, z)}{\\Delta y} \\\\ &amp;+\\frac{\\sigma _{xz}(x,y,z+\\Delta z)-\\sigma _{xz}(x, y, z)}{\\Delta z} = f_x(x,y,z) \\end{split} \\end{equation} for the \\(x\\)-component of Eq. \\eqref{eqn:forceeq}. Here \\(f_x=F_x/\\Delta x \\Delta y \\Delta z\\) is a volume force. In the limit \\(\\Delta x\\to 0\\) and \\(\\Delta y\\to 0\\) this becomes \\begin{equation} \\frac{\\partial \\sigma _{xx}}{\\partial x} + \\frac{\\partial \\sigma _{xy}}{\\partial y} + \\frac{\\partial \\sigma _{xz}}{\\partial z} = f_x. \\end{equation} From the \\(y\\) and \\(z\\)-component of Eq. \\eqref{eqn:forceeq} we get two more differential equations, \\begin{align} \\frac{\\partial \\sigma _{yx}}{\\partial x} + \\frac{\\partial \\sigma _{yy}}{\\partial y} + \\frac{\\partial \\sigma _{yz}}{\\partial z} &amp;= f_y \\\\ \\frac{\\partial \\sigma _{zx}}{\\partial x} + \\frac{\\partial \\sigma _{zy}}{\\partial y} + \\frac{\\partial \\sigma _{zz}}{\\partial z} &amp;= f_z. \\end{align} . These can be summarized to the compact notation \\begin{equation} \\label{eqn:Equi_condition} \\nabla \\cdot \\t{\\sigma }=\\v{f}. \\end{equation} Equation \\eqref{eqn:Equi˙condition} is the central expression of elastostatics that describes force balance within a solid body. An alternative derivation of force balance invokes Gauss’ theorem. We can integrate Eq. \\eqref{eqn:Equi˙condition} over a volume element inside this body of volume \\(V\\) and surface area \\(S(V)\\). Using Gauss’ theorem (sometimes also called the divergence theorem), we obtain \\begin{equation} \\label{eqn:sum_of_forces_in_V} \\int _V d^3 r \\ \\nabla \\cdot \\t{\\sigma } = \\int _{S(V)} d^2 r \\ \\t{\\sigma } \\cdot \\v{e}_S = \\int _{S(V)} d^2 r \\ d\\v{F} = \\int _V d^3 r \\ \\v{f} \\end{equation} where \\(\\v{e}_S\\) is the normal vector pointing outwards on \\(S(V)\\). The infinitesimal area vector \\(\\v{e}_S d^2 r\\) is hence transformed into an (infinitesimal) force vector \\(d \\v{F} = \\t{\\sigma } \\cdot \\v{e}_S \\ d^2 r\\) and integrated over. Eq. \\eqref{eqn:sum˙of˙forces˙in˙V} hence contains a sum over all forces acting on the surface of the volume element \\(V\\), and these forces must sum to the body force. It is nothing else than a statement of force balance for any volume element within the solid body. Note: Notation – Note that \\(\\nabla \\cdot \\t{\\sigma } \\equiv \\text{div} \\ \\t{\\sigma }\\). Sometimes it is useful to make use of Einstein summation, i.e. implicit summation over repeated indices within the same quantity of in products. Examples are: \\(\\nabla \\cdot \\t{\\sigma } = \\partial _{i} \\sigma _{ij} = \\sum _i \\partial _{i} \\sigma _{ij}, 3\\,\\sigma _h = \\sigma _{kk} = \\sum _k \\sigma _{kk} = tr \\,\\t{\\sigma }\\), where \\(\\sigma _h\\) is the hydrostatic stress. In the solid mechanics literature, derivatives are often expressed as indices following a comma. For example, the derivative of the function \\(f(x,y,z)\\) with respect to \\(x\\) would be written as \\(f_{,x}\\). In this notation, Eq. \\eqref{eqn:Equi˙condition} becomes \\(\\nabla \\cdot \\t{\\sigma } = \\partial _{i} \\sigma _{ij} = \\sigma _{ij,i}=0\\). By virtue of the Einstein summation convention we need to sum over the repeated index \\(i\\) in the right hand side expression. Vector/tensor and component notation with Einstein summation will be used intermixed throughout these notes. Moment equilibrium . Besides equilibrium of forces, we also need to fulfills the equilibrium of moments acting on the volume element. The moment around the \\(z\\)-axis is given by \\begin{equation} Y_x \\Delta y + X_y \\Delta x = 0 \\end{equation} which immediately implies \\(\\sigma _{yx}=\\sigma _{xy}\\). The moment equilibrium around the \\(x\\)- and \\(y\\)-axes leads to conditions on the other off-diagonal components of \\(\\t{\\sigma }\\), \\(\\sigma _{zx}=\\sigma _{xz}\\) and \\(\\sigma _{zy}=\\sigma _{yz}\\). By virtue of moment balance, the stress tensor is a symmetric tensor, \\(\\sigma _{ij}=\\sigma _{ji}\\) or \\(\\t{\\sigma }=\\t{\\sigma }^T\\). 4.2 Force equilibria in three dimensions . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=e5d1512d-7a80-4e79-8ea1-ac82015e82df . ",
    "url": "http://localhost:4000/_lecture/chapter04.html#x1-10004",
    "relUrl": "/_lecture/chapter04.html#x1-10004"
  },"10": {
    "doc": "Chapter 04",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter04.html#x1-70004.2",
    "relUrl": "/_lecture/chapter04.html#x1-70004.2"
  },"11": {
    "doc": "Chapter 04",
    "title": "Chapter 04",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter04.html",
    "relUrl": "/_lecture/chapter04.html"
  },"12": {
    "doc": "Chapter 05",
    "title": "Chapter 5Stress",
    "content": "5.1 Rotating the stress tensor . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=7103f19f-f4b0-4d11-9030-ac82015e8337 . 5.2 Principal stresses . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=5cdff30a-9f6b-47cb-bc25-ac82015e830b . 5.3 Stress invariants . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=11d2e291-bdf5-4f2b-8134-ac8300604f90 . ",
    "url": "http://localhost:4000/_lecture/chapter05.html#x1-10005",
    "relUrl": "/_lecture/chapter05.html#x1-10005"
  },"13": {
    "doc": "Chapter 05",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter05.html#x1-50005.3",
    "relUrl": "/_lecture/chapter05.html#x1-50005.3"
  },"14": {
    "doc": "Chapter 05",
    "title": "Chapter 05",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter05.html",
    "relUrl": "/_lecture/chapter05.html"
  },"15": {
    "doc": "Chapter 06",
    "title": "Chapter 6Strain and displacement",
    "content": "6.1 Strain . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=1a7ba6e0-1cdb-4422-b7a5-ac9100b5586c . 6.2 Displacement . The displacement field \\(\\v{u}(\\v{r})\\) describes how a point on our solid body moves during deformation. For a rigid body \\(\\v{u}\\equiv 0\\), but for a deformable body we obtain finite displacements during deformation. The point \\(\\v{r}\\) then moves to the point \\(\\v{r}^\\prime (\\v{r}) = \\v{r} + \\v{u}(\\v{r})\\). The displacement field \\(\\v{u}(\\v{r})=\\v{r} - \\v{r}^\\prime (\\v{r})\\) is hence the difference of the deformed (“displaced”) point to its reference position \\(\\v{r}\\). Note that the displacement field itself is defined as a function of this reference position \\(\\v{r}\\). 6.3 Strain . The strain field in the small strain approximation is given by the symmetrized gradient of \\(\\v{u}(\\v{r})\\), \\begin{equation} \\label{eqn:Strain_gradient} \\t{\\varepsilon }(\\v{r}) = \\frac{1}{2} \\left (\\nabla \\v{u} + (\\nabla \\v{u})^T\\right ). \\end{equation} The left hand side of Eq. \\eqref{eqn:Strain˙gradient} contains the gradient of a vector field, \\(\\nabla \\v{u}\\), which is a second rank tensor, \\begin{equation} \\nabla \\v{u} = \\begin{pmatrix} \\frac{\\partial u_x}{\\partial x} &amp; \\frac{\\partial u_x}{\\partial y} &amp; \\frac{\\partial u_x}{\\partial z} \\\\ \\frac{\\partial u_y}{\\partial x} &amp; \\frac{\\partial u_y}{\\partial y} &amp; \\frac{\\partial u_y}{\\partial z} \\\\ \\frac{\\partial u_z}{\\partial x} &amp; \\frac{\\partial u_z}{\\partial y} &amp; \\frac{\\partial u_z}{\\partial z} \\end{pmatrix}, \\end{equation} whose components are given by \\([\\nabla \\v{u}]_{ij}=\\partial u_i/\\partial r_j = u_{i,j}\\). It is not the divergence, \\(\\nabla \\cdot \\v{u}\\) which would give a scalar. This potential source of confusion can be avoided by writing the equation in the component-wise notation, \\begin{equation} \\label{eqn:Strain_gradient_comp} \\varepsilon _{ij} = \\frac{1}{2} (\\partial _i u_j + \\partial _j u_i) = \\frac{1}{2} (u_{j,i} + u_{i,j}). \\end{equation} (Note that these expression do not contain a sum since there is no repeated index.) . The geometric interpretation of the strain is that is converts a vector \\(\\v{r}\\) that has a direction and length into the change this vector undergoes under deformation: \\(\\v{u}=\\t{\\varepsilon }\\cdot \\v{r}\\) with the new (transformed) vector \\(\\v{r}'=\\v{r}+\\v{u}=(1+\\t{\\varepsilon })\\cdot \\v{r}\\). In terms of thinking about tensors as a representation of a linear transformation, the strain tensor transforms a position into a displacement. The strain tensor is dimensionless. ",
    "url": "http://localhost:4000/_lecture/chapter06.html#x1-10006",
    "relUrl": "/_lecture/chapter06.html#x1-10006"
  },"16": {
    "doc": "Chapter 06",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter06.html#x1-50006.3",
    "relUrl": "/_lecture/chapter06.html#x1-50006.3"
  },"17": {
    "doc": "Chapter 06",
    "title": "Chapter 06",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter06.html",
    "relUrl": "/_lecture/chapter06.html"
  },"18": {
    "doc": "Chapter 07",
    "title": "Chapter 7Hooke’s law",
    "content": "https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=6580c65e-93a2-4e11-9a50-ac9100b55895 . Finally, we need a constitutive relation (material law) to close Eqs. \\eqref{eqn:Equi˙condition} and \\eqref{eqn:Strain˙gradient}. Since we will be working in linear elasticity, the constitutive equation is a linear relationship between \\(\\t{\\sigma }\\) and \\(\\t{\\varepsilon }\\). The most general form of this linear relationship is \\begin{equation} \\label{eqn:Hookeslaw} \\t{\\sigma } = \\t{\\t{C}} : \\t{\\varepsilon }, \\text{or using Einstein summation} \\ \\sigma _{ij} = C_{ijkl} \\varepsilon _{kl}. \\end{equation} It is called Hooke’s law. The quantity \\(\\t{\\t{C}}\\) is a fourth order symmetric tensor of elastic constants that contains at most 21 independent elastic moduli. To see that there are only \\(21\\) independent coefficients, it is useful to remove the symmetric entries from \\(\\t{\\sigma }\\) and \\(\\t{\\varepsilon }\\) and express them as 6-vectors in Voigt notation, \\begin{equation} \\label{eqn:sig_eps_Voigt} \\v{\\sigma } = (\\sigma _{xx},\\sigma _{yy},\\sigma _{zz},\\sigma _{yz},\\sigma _{xz},\\sigma _{xy}) \\ \\text{and} \\ \\v{\\varepsilon } = (\\varepsilon _{xx},\\varepsilon _{yy},\\varepsilon _{zz},2\\varepsilon _{yz},2\\varepsilon _{xz},2\\varepsilon _{xy}). \\end{equation} Then \\(\\sigma =\\t{C} \\cdot \\v{\\varepsilon }\\) where \\(\\t{C}\\) is a \\(6\\times 6\\) symmetric matrix called the stiffness matrix containing the above-mentioned 21 independent elastic constants. (There are \\(6\\cdot 6=36\\) components, but the matrix is symmetric.) . Note that the off-diagonal components of \\(\\t{\\sigma }\\) are often denoted by \\(\\tau _{xy} \\equiv \\sigma _{xy}, \\tau _{xz} \\equiv \\sigma _{xz}\\ \\text{and}\\ \\tau _{yz} \\equiv \\sigma _{yz}\\). The off-diagonal components of \\(\\t{\\varepsilon }\\) are often denoted by \\(\\gamma _{xy} \\equiv 2\\varepsilon _{xy}, \\gamma _{xz} \\equiv 2\\varepsilon _{xz}\\ \\text{and}\\ \\gamma _{yz} \\equiv 2\\varepsilon _{yz}\\) and absorb the factor of 2 that occurs in Eq. \\eqref{eqn:sig˙eps˙Voigt}. Voigt notation then becomes \\begin{equation} \\label{eqn:sig_eps_Voigt_gamma} \\v{\\sigma } = (\\sigma _{xx},\\sigma _{yy},\\sigma _{zz},\\tau _{yz},\\tau _{xz},\\tau _{xy}) \\ \\text{and} \\ \\v{\\varepsilon } = (\\varepsilon _{xx},\\varepsilon _{yy},\\varepsilon _{zz},\\gamma _{yz},\\gamma _{xz},\\gamma _{xy}) \\end{equation} . Note: It is important to keep in mind that the \\(\\gamma \\)’s contain a factor 2 but the \\(\\tau \\)’s do not. The factor of 2 ensures that \\(\\v{\\sigma }=\\t{C} \\cdot \\v{\\varepsilon }\\) and \\(\\t{\\sigma } = \\t{\\t{C}} : \\t{\\varepsilon }\\) are the same constitutive law. For isotropic elasticity, the total 21 independent elastic constants reduce to two. The constitutive equation for isotropic elasticity is \\begin{equation} \\label{eqn:Isotropic_elasticity} \\sigma _{ij} = \\lambda \\delta _{ij} \\varepsilon _{kk} + 2\\mu \\varepsilon _{ij} \\end{equation} or its inverse \\begin{equation} \\label{eqn:Isotropic_elasticity_inverse} \\varepsilon _{ij} = \\frac{1}{2G} \\sigma _{ij} - \\frac{\\nu }{E} \\delta _{ij} \\delta _{kk} = \\frac{1}{E} [(1+\\nu )\\sigma _{ij} - \\nu \\delta _{ij} \\sigma _{kk}], \\end{equation} where \\(\\delta _{ij}\\) is the Kronecker-Delta. These expressions have been conveniently written in their most simple form. The constants that show up in Eqs. \\eqref{eqn:Isotropic˙elasticity} and \\eqref{eqn:Isotropic˙elasticity˙inverse} are the shear modulus \\(\\mu \\), Lamé’s first constant \\(\\lambda \\), Young’s modulus \\(E\\) and Poisson number \\(\\nu \\). Both \\(\\lambda \\) and \\(\\nu \\) are often called Lamé’s constants. Note that \\(\\sigma _{kk} = 3\\sigma _h\\) (Einstein summation!) where \\(3\\sigma _h\\) is the hydrostatic stress. The four moduli are not independent (only two are), and the following expressions relate the pairs \\(\\lambda \\), \\(\\mu \\) and \\(E\\), \\(\\nu \\) to each other: \\begin{align} \\label{eqn:Relation_Lame} \\lambda &amp;= \\frac{E\\nu }{(1+\\nu )(1-2\\nu )} \\\\ \\mu &amp;= \\frac{E}{2(1+\\nu )} \\\\ \\lambda + \\mu &amp;= \\frac{E}{2(1+\\nu )(1-2\\nu )} \\\\ E &amp;= \\frac{\\mu (3\\lambda + 2\\mu )}{\\lambda + \\mu } \\\\ \\nu &amp;= \\frac{\\lambda }{2(\\lambda + \\mu )} \\end{align} . Note that the volumetric strain \\(\\varepsilon _h = \\frac{1}{3}\\:{\\rm tr} \\ \\t{\\varepsilon } = \\frac{1}{E} [(1 + \\nu )\\sigma _h - 3\\, \\nu \\sigma _h] = \\frac{1}{E} (1-2\\nu )\\sigma _h\\) vanishes at \\(\\nu = 1/2\\). In this case, \\(\\sigma _{ij} = 2\\sigma _h \\varepsilon _{ij}\\) because the \\(\\varepsilon _h = \\varepsilon _{kk}\\) must vanish. Note that another common symbol for the shear modulus \\(\\mu \\) is the Latin letter \\(G\\). We can also write down a free energy functional (often also called a hyperelastic energy density), which is quadratic in the strain \\(\\t{\\varepsilon }\\), \\begin{equation} \\label{eqn:Free_energy} W = \\frac{1}{2} \\lambda \\varepsilon _{ii}^2 + \\mu \\varepsilon _{ij}^2 \\end{equation} Using \\(\\sigma _{ij} = \\partial W / \\partial \\varepsilon _{ij}\\) recovers the above constitutive expression Eq. \\eqref{eqn:Isotropic˙elasticity}. From the free energy functional we see that any isotropic material must have \\(\\lambda &gt; 0\\) and \\(\\mu &gt; 0\\), otherwise the energy could be made arbitrarily small by increasing the deformation of the solid. This limits the Poisson number to the range \\( -1 &lt; \\nu &lt; 1/2 \\). Note that \\(\\nu &lt;0\\) is typically only achieved for architectured materials such as foams or metamaterials. https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=61fa9204-ff9c-4874-b217-acaa0109e189 . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=2f5be83c-cd57-41c8-aa7a-acaa0109e1f0 . ",
    "url": "http://localhost:4000/_lecture/chapter07.html#x1-10007",
    "relUrl": "/_lecture/chapter07.html#x1-10007"
  },"19": {
    "doc": "Chapter 07",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter07.html#x1-20007",
    "relUrl": "/_lecture/chapter07.html#x1-20007"
  },"20": {
    "doc": "Chapter 07",
    "title": "Chapter 07",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter07.html",
    "relUrl": "/_lecture/chapter07.html"
  },"21": {
    "doc": "Chapter 08",
    "title": "Chapter 8Plane problems",
    "content": "https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=7ebb9e3e-c8c8-4640-ab4b-acaa0109e1b4 . Plane problems are problems where the system has a symmetry in a certain direction. We will here use the \\(y\\)-direction as the direction in which the plane conditions hold. This symmetry implies that the relevant quantities do not vary in \\(z\\)-direction. Note that throughout this text, we will switch this direction. 8.1 Plane strain . For a plane strain situation, the system cannot elongate or shrink in that direction and hence \\(\\varepsilon _{yy} = 0\\). From Eq. \\eqref{eqn:Isotropic˙elasticity˙inverse} we see that \\begin{equation} \\label{eqn:planestrainzz} \\varepsilon _{yy} = \\frac{1+\\nu }{E} \\sigma _{yy} - \\frac{\\nu }{E} (\\sigma _{xx} + \\sigma _{yy} + \\sigma _{zz}) = 0 \\end{equation} and hence \\begin{equation} \\label{eqn:planestrain_stressyy} \\sigma _{yy} = \\nu (\\sigma _{xx} + \\sigma _{zz}) \\end{equation} With the two relations for \\(\\varepsilon _{yy}\\) and \\(\\sigma _{yy}\\) we can express Hooke’s law as \\begin{align} \\label{eqn:planestrain_Hooksxx} \\varepsilon _{xx} &amp;= \\frac{1-\\nu ^2}{E} \\sigma _{xx} - \\frac{\\nu (1+\\nu )}{E} \\sigma _{zz} \\\\ \\label{eqn:planestrain_Hooksyy} \\varepsilon _{zz} &amp;= -\\frac{\\nu (1+\\nu )}{E} \\sigma _{xx} + \\frac{1-\\nu ^2}{E} \\sigma _{zz} \\end{align} . and its inverse \\begin{align} \\label{eqn:planestrain_Hooksinversexx} \\sigma _{xx} &amp;= (\\lambda + 2\\nu ) \\varepsilon _{xx} + \\lambda \\varepsilon _{zz} \\\\ \\label{eqn:planestrain_Hooksinverseyy} \\sigma _{zz} &amp;= \\lambda \\varepsilon _{xx} + (\\lambda + 2\\mu ) \\varepsilon _{zz} \\end{align} . Note that the condition for elastic equilibrium Eq. \\eqref{eqn:Equi˙condition} becomes (in Cartesian coordinates) \\begin{align} \\label{eqn:planestrain_elastic_equixx} \\frac{\\partial \\sigma _{xx}}{\\partial x} + \\frac{\\partial \\sigma _{xz}}{\\partial z} &amp;= 0 \\\\ \\label{eqn:planestrain_elastic_equizz} \\frac{\\partial \\sigma _{zz}}{\\partial z} + \\frac{\\partial \\sigma _{xz}}{\\partial x} &amp;= 0 \\end{align} . 8.2 Plane stress conditions . For plane stress we consider a situation with \\(\\sigma _{yy} = 0\\), i.e. there is no stress in the \\(y\\)-direction. This is a good approximation for example for a thin plate. In this limit, Hooke’s law becomes \\begin{align} \\label{eqn:planestresse1} \\varepsilon _{xx} &amp;= \\frac{1}{E} (\\sigma _{xx} - \\nu \\sigma _{zz}) \\\\ \\label{eqn:planestresse2} \\varepsilon _{zz} &amp;= \\frac{}{E} (-\\nu \\sigma _{xx} + \\sigma _{zz}) \\end{align} . and its inverse \\begin{align} \\label{eqn:planestresss1} \\sigma _{xx} &amp;= \\frac{E}{1-\\nu ^2} (\\varepsilon _{xx} + \\nu \\varepsilon _{zz}) \\\\ \\label{eqn:planestresss2} \\sigma _{zz} &amp;= \\frac{E}{1-\\nu ^2} (\\nu \\varepsilon _{xx} + \\varepsilon _{zz}). \\end{align} . Note that plane strain and plane stress are described by the same set of differential equation but with different elastic moduli. For example, we can convert the plane stress Eqs. \\eqref{eqn:planestresse1}-\\eqref{eqn:planestresss2} to the corresponding plane strain equation by substituting the elastic constants, \\begin{equation} E \\to \\frac{E}{1-\\nu ^2}\\quad \\text{and}\\quad \\nu \\to \\frac{\\nu }{1-\\nu }. \\end{equation} Hence any plane stress solution can be converted into a plane strain solution using this substitution. In the following, we will continue to work with the plane stress expression (because they are simpler), but all results carry over to plane strain with this substitution. 8.3 Compatibility condition . Another condition to be fulfilled is the compatibility condition. For plane problems, the compatibility conditions is the single equation: \\begin{equation} \\label{eqn:Compatibility_eqn} \\frac{\\partial ^2 \\varepsilon _{xx}}{\\partial z^2} + \\frac{\\partial ^2 \\varepsilon _{zz}}{\\partial x^2} = 2\\ \\frac{\\partial ^2 \\varepsilon _{xz}}{\\partial x \\partial z} \\end{equation} That it must hold is easily seen by expressing the strain in Eq. \\eqref{eqn:Compatibility˙eqn} in terms of the displacements \\(\\v{u}\\) using Eq. \\eqref{eqn:Strain˙gradient}. It is therefore a consequence of the fact that the strain field is the gradient of the displacement field. It is similar to the well-known condition that the curl of a gradient has to disappear. The compatibility condition has a simple geometric explanation. Imaging a jigsaw puzzle that you deform in its assembled state. Even in the deformed state, all pieces still have to fit together. They deformation of neighboring pieces can therefore not be independent of each other. ",
    "url": "http://localhost:4000/_lecture/chapter08.html#x1-10008",
    "relUrl": "/_lecture/chapter08.html#x1-10008"
  },"22": {
    "doc": "Chapter 08",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter08.html#x1-50008.3",
    "relUrl": "/_lecture/chapter08.html#x1-50008.3"
  },"23": {
    "doc": "Chapter 08",
    "title": "Chapter 08",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter08.html",
    "relUrl": "/_lecture/chapter08.html"
  },"24": {
    "doc": "Chapter 09",
    "title": "Chapter 9Beams",
    "content": "9.1 Stresses . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=4555e4d3-94b0-450d-92f7-acac00e98b5f . Assume a rectangular beam in plane stress or plane strain subject to bending. (The “plane” direction is the \\(y\\)-direction.) The surface normal of the beam is oriented in \\(z\\)-direction. Bending will give rise to internal stresses inside of the beam. We will require that these stresses comply with the external shear force \\(Q(x)\\) and bending moment \\(M(x)\\) in the weak or integral sense, \\begin{align} \\label{eq:beamweakforce} Q(x) &amp;= \\int _A dy dz\\, \\tau _{xz}(x, z) \\\\ \\label{eq:beamweakmoment} M(x) &amp;= \\int _A dy dz\\, z\\sigma _{xx}(x, z). \\end{align} . Because of the plane state, integration in \\(y\\)-direction will only yield a constant factor, the width \\(t\\) of the beam. We can derive a condition equivalent to static equilibrium, \\(\\sigma _{ij,j}=0\\), for the weak quantities defined in Eqs. \\eqref{eq:beamweakforce} and \\eqref{eq:beamweakmoment}. Taking the derivative of \\(Q(x)\\) yields \\begin{equation} Q_{,x} = \\int _A dydz\\, \\tau _{xz,x} = -\\int _A dydz\\, \\sigma _{zz,z} = -t \\left [\\sigma _{zz}(x, h/2) - \\sigma _{zz}(x, -h/2)\\right ]. \\end{equation} We call the quantity \\(q(x)\\equiv t \\left [\\sigma _{zz}(x, h/2) - \\sigma _{zz}(x, -h/2)\\right ]\\) the line load of the beam. Next, we take the derivative of \\(M(x)\\), \\begin{equation} M_{,x} = \\int _A dydz\\, z\\sigma _{xx,x} = -\\int _A dydz\\, z\\tau{xz,z} =-t\\left [z\\tau _{xz}\\right ]_{-h/2}^{h/2} + \\int _A dydz\\, z\\tau _{xz}. \\end{equation} The first term on the right hand side vanishes because the surfaces are traction free, \\(\\tau _{xz}=0\\) at \\(z=h/2\\) and \\(z=-h/2\\). This yields \\begin{align} Q_{,x} &amp;= -q(x) \\\\ M_{,x} &amp;= Q(x) \\end{align} . for the weak form of the equilibrium conditions. We now assume that the stress is a linear function of the position \\(z\\) perpendicular to the beam axis, \\begin{equation} \\label{eq:beamstress1} \\sigma _{xx}(x,z) = C(x) z. \\end{equation} In what follow we show that this is a good assumption, i.e. we can fulfill force and moment equilibrium and the resulting strains fulfill the compatibility conditions. Note: The theory derived in this chapter is commonly referred to as the Euler-Bernoulli beam theory. The starting point of this theory is typically not Eq. \\eqref{eq:beamstress1}, but the assumption that each cross section will remain plane and undergo small rotations during deformation. These are sometimes called the Bernoulli assumptions. They implies that the strain \\(\\varepsilon _{xx}\\propto z\\) rather than the stress. It is often argued that \\(\\sigma _{xx}=E \\varepsilon _{xx}\\) but this of course ignores the other components of the strain tensor. As will be seen below, the Bernoulli assumptions are actually wrong but assuming a linear stress profile leads to the correct small strain expression for the deformation of a beam. It is straightforward to compute the bending moment, \\begin{equation} \\label{eq:beammoment} M(x) = \\int _A dy dz\\, \\sigma _{xx}(x, z) z = C(x) \\int _A dy dz\\, z^2 = C(x) I_y, \\end{equation} where \\(A\\) is the cross-section of the beam and \\(I_y\\) is the axial moment of inertia. For a rectangular beam of height \\(h\\) and width \\(t\\), \\(I_y=h^3 t/12\\). The moment of inertia is a geometric factor and depends on the shape of the cross-section of the beam. We can rewrite Eq. \\eqref{eq:beamstress1} as \\begin{equation} \\label{eq:beamstressxx} \\sigma _{xx}(x,z) = \\frac{M(x)}{I_y} z. \\end{equation} Note that an additional longitudinal force \\(L\\) will simple be an additive contribution to Eq. \\eqref{eq:beamstressxx}, \\(\\sigma _{xx}(x,z) = M(x)/I_y z + L/A\\). We can now use the condition for static equilibrium to compute the full stress tensor \\(\\t{\\sigma }\\). From \\(\\sigma _{xx,x} + \\tau _{xz,z}=0\\) we obtain \\begin{equation} \\tau _{xz,z} = - \\frac{z}{I_y} M_{,x} = - \\frac{z}{I_y} Q(x). \\end{equation} We can integrate this across the height \\(h\\) of the beam, keeping in mind that \\(\\tau _{xz}=0\\) at a traction-free surface, to yield \\begin{equation} \\label{eq:beamstressxz} \\tau _{xz}(x, z) = \\frac{Q(x)}{2I_y} \\left (\\frac{h^2}{4} - z^2\\right ). \\end{equation} Next, we use \\(\\sigma _{zz,z}+\\tau _{xz,x}=0\\) to obtain \\begin{equation} \\sigma _{zz,z} = - \\frac{1}{2I_y} Q_{,x} \\left (\\frac{h^2}{4} - z^2\\right ) = \\frac{q(x)}{2I_y} \\left (\\frac{h^2}{4} - z^2\\right ). \\end{equation} We need to integrate this equation again, but now \\(\\sigma _{zz}\\not =0\\) at the surface since the beam is subject to a line load \\(q(x)\\). Rather, we need the condition that the loads on top and bottom surface of the beam balance, \\(\\sigma _{zz}(x,h/2)=-\\sigma _{zz}(x,-h/2)\\). This gives \\begin{equation} \\label{eq:beamstresszz} \\sigma _{zz}(x, z) = \\frac{q(x)}{2I_y} \\left (\\frac{h^2}{4} - \\frac{z^2}{3}\\right ) z \\end{equation} with \\begin{equation} \\label{eq:beambczz} \\sigma _{zz}(x,h/2)=\\frac{q(x)h^3}{24I_y}=\\frac{q(x)}{2t} \\end{equation} where \\(t\\) is the width of the beam. Note that in this derivation, we have required that the stress gives rise to a certain bending moment through Eq. \\eqref{eq:beammoment}. Since we do not prescribe the specific stress state \\(\\sigma _{xx}(x, z)\\) but only its integral, this is a weak condition. Similarly, integration of Eq. \\eqref{eq:beamstressxz} in accordance with Eq. \\eqref{eq:beamweakforce} gives \\begin{equation} \\int _{-t/2}^{t/2} dy \\int _{-h/2}^{h/2} dz\\, \\tau _{xz}(x, z) = Q(x), \\end{equation} i.e. the force acting on the cross-section at position \\(x\\) along the beam. Again, this condition is fulfilled in the integral, i.e. in the weak sense. 9.2 Displacements . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=8e0b3bab-8abc-4c2a-87cc-acac00e98b92 . Now that the know the stress inside the beam, we can compute the displacement and thereby the deformation of the beam from Hooke’s law. Starting from Hooke’s law, \\begin{align} \\label{eq:beamhooke1} \\varepsilon _{xx} \\equiv u_{x,x} &amp;= \\sigma _{xx}/E - \\nu \\sigma _{zz}/E \\\\ \\label{eq:beamhooke2} 2\\varepsilon _{xz} \\equiv u_{x,z} + u_{z,x} &amp;= 2(1+\\nu )\\tau _{xz}/E, \\end{align} . and taking the derivative of Eq. \\eqref{eq:beamhooke2} with respect to \\(x\\), we obtain \\begin{equation} u_{x,xz} + u_{z,xx}=2(1+\\nu )\\tau _{xz,x}/E \\end{equation} and \\begin{equation} u_{x,xz} + u_{z,xx}=\\partial _z( u_{x,x}) + u_{z,xx}=u_{z,xx} + (\\sigma _{xx,z} - \\nu \\sigma _{zz,z})/E. \\end{equation} Combining these two equations yields \\begin{equation} u_{z,xx} = \\left [2(1+\\nu )\\tau _{xz,x} - \\sigma _{xx,z} + \\nu \\sigma _{zz,z}\\right ]/E, \\end{equation} where we now insert Eqs. \\eqref{eq:beamstressxx}, \\eqref{eq:beamstressxz} and \\eqref{eq:beamstresszz}. This gives \\begin{equation} u_{z,xx} = \\frac{1}{E I_y} \\left [-\\left (1+\\frac{\\nu }{2}\\right ) \\left (\\frac{h^2}{4} - z^2\\right )q(x) - M(x)\\right ], \\end{equation} which at the surface of the beam \\(w(x)=u_z(x,h/2)\\) becomes \\begin{equation} E I_y w_{,xx} = - M(x). \\end{equation} This equation is called the Euler-Bernoulli beam equation. By using \\(M_{xx}=-q(x)\\) we can write this as \\begin{equation} (E I_y w_{,xx})_{,xx} = q(x), \\end{equation} in terms of the line load \\(q(x)\\), or \\begin{equation} E I_y w_{,xxxx} = q(x), \\end{equation} if \\(E I_y\\) does not depend on position \\(x\\). 9.3 Buckling . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=95ca7b6a-0bf7-441e-9ca0-acb901506883 . ",
    "url": "http://localhost:4000/_lecture/chapter09.html#x1-10009",
    "relUrl": "/_lecture/chapter09.html#x1-10009"
  },"25": {
    "doc": "Chapter 09",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter09.html#x1-50009.3",
    "relUrl": "/_lecture/chapter09.html#x1-50009.3"
  },"26": {
    "doc": "Chapter 09",
    "title": "Chapter 09",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter09.html",
    "relUrl": "/_lecture/chapter09.html"
  },"27": {
    "doc": "Chapter 10",
    "title": "Chapter 10Plates",
    "content": "https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=567d8212-1aeb-4360-90e4-acb901506868 . 10.1 Stress . Kirchhoff plate theory is the straightforward generalization of Euler-Bernoulli beam theory to plates. We abandon the plane situation in which all derivatives in \\(y\\)-direction vanish. The weak boundary conditions then become \\begin{align} \\label{eq:beamweakforcex} Q_x(x,y) &amp;= \\int _h dz\\, \\tau _{xz}(x, y, z) \\\\ \\label{eq:beamweakforcey} Q_y(x,y) &amp;= \\int _h dz\\, \\tau _{yz}(x, y, z) \\\\ \\label{eq:beamweakmomentxx} M_{xx}(x, y) &amp;= \\int _h dz\\, z \\sigma _{xx}(x, y, z) \\\\ \\label{eq:beamweakmomentyy} M_{yy}(x, y) &amp;= \\int _h dz\\, z \\sigma _{yy}(x, y, z) \\\\ \\label{eq:beamweakmomentxy} M_{xy}(x, y) &amp;= \\int _h dz\\, z \\tau _{xy}(x, y, z), \\end{align} . where the integral is over the height \\(h\\) of the plate. \\(Q_x\\) and \\(Q_y\\) are called shear forces, \\(M_{xx}\\) and \\(M_{yy}\\) are bending moments and \\(M_{xy}\\) is the torsional moment. Note that employing static equilibrium \\(\\sigma _{ij,j}=0\\) we obtain \\begin{equation} Q_{x,x} + Q_{y,y} = \\int _{-h/2}^{h/2} dz\\, \\left ( \\tau _{zx,x} + \\tau _{zy,y} \\right ) = -\\int _{-h/2}^{h/2} dz\\, \\tau _{zz,z} \\end{equation} but \\begin{equation} \\int _{-h/2}^{h/2} dz\\, \\tau _{zz,z} = \\tau _{zz}(x, y, h/2) - \\tau _{zz}(x, y, -h/2) \\equiv p(x,y) \\end{equation} where \\(p(x,y)\\) is the pressure on the plate (cf. also the corresponding equation Eq. \\eqref{eq:beambczz} for the beam). Similarly \\begin{equation} M_{xx,x} + M_{xy,y} = \\int _{-h/2}^{h/2} dz\\, z\\left ( \\tau _{xx,x} + \\tau _{xy,y} \\right ) = -\\int _{-h/2}^{h/2} dz\\, z\\tau _{xz,z} \\end{equation} and \\begin{equation} \\int _{-h/2}^{h/2} dz\\, z\\tau _{xz,z} = \\left [z\\tau _{xz}\\right ]_{-h/2}^{h/2} - \\int _{-h/2}^{h/2} dz\\, \\tau _{xz} = -Q_x. \\end{equation} where the last equality holds because \\(\\tau _{xz}(x,y,h/2)=-\\tau _{xz}(x,y,-h/2)\\). The condition for static equilibrium \\(\\sigma _{ij,j}=0\\) therefore becomes \\begin{align} \\label{eq:plateeq1} Q_{x,x} + Q_{y,y} &amp;=-p(x,y) \\\\ \\label{eq:plateeq2} M_{xx,x} + M_{xy,y}&amp;=Q_x(x,y) \\\\ \\label{eq:plateeq3} M_{xy,x} + M_{yy,y}&amp;=Q_y(x,y) \\end{align} . in the weak form. Note that this can be written in the compact form \\(Q_{i,i}=-p\\) and \\(M_{ij,j}=Q_i\\). As in the Euler-Bernoulli case, we assume that the components \\(\\sigma _{xx}\\), \\(\\sigma _{yy}\\) and \\(\\tau _{xy}\\) vary linearly with \\(z\\). We can write \\begin{align} \\sigma _{xx}(x, y, z) &amp;= \\frac{M_{xx}(x, y)}{I} z \\\\ \\sigma _{yy}(x, y, z) &amp;= \\frac{M_{yy}(x, y)}{I} z \\\\ \\tau _{xy}(x, y, z) &amp;= \\frac{M_{xy}(x, y)}{I} z \\end{align} . with \\(I=\\int dz\\, z^2=h^3/12\\). The remaining components of the stress tensor are obtained from static equilibrium. Static equilibrium yields \\begin{equation} \\tau _{xz,z} = -\\frac{z}{I} Q_x \\quad \\text{and}\\quad \\tau _{yz,z} = -\\frac{z}{I} Q_y \\end{equation} which can be integrated under the condition \\(\\tau _{xz}(x, y, h/2)=\\tau _{xz}(x, y, -h/2)=0\\) to \\begin{equation} \\tau _{xz}(x, y, z) = \\frac{Q_x}{2I} \\left (\\frac{h^2}{4}-z^2\\right ) \\quad \\text{and}\\quad \\tau _{yz}(x, y, z) = \\frac{Q_y}{2I} \\left (\\frac{h^2}{4}-z^2\\right ). \\end{equation} This is analogous to Eq. \\eqref{eq:beamstressxz} for the beam. We are finally left with finding an expression for \\(\\sigma _{zz}\\). Again we use static equilibrium to obtain \\begin{equation} \\sigma _{zz,z} = -\\tau _{xz,x}-\\tau _{yz,y} = \\frac{p(x,y)}{2I} \\left (\\frac{h^2}{4}-z^2\\right ). \\end{equation} Integration under the condition that the loads on top and bottom surface of the plate balance, \\(\\sigma _{zz}(x,h/2)=-\\sigma _{zz}(x,-h/2)\\), gives \\begin{equation} \\label{eq:platestresszz} \\sigma _{zz}(x, y, z) = \\frac{p(x, y)}{2I} \\left (\\frac{h^2}{4} - \\frac{z^2}{3}\\right ) z. \\end{equation} At the top and bottom of the plate we find \\(\\sigma _{zz}(x,h/2)=-\\sigma _{zz}(x,-h/2)=p(x,y)/2\\). 10.2 Displacements . Now that we know the stress inside the plate, we can again compute the displacements from Hooke’s law. In the full three-dimensional case, Hooke’s law, \\begin{align} \\label{eq:platehooke1} \\varepsilon _{xx} \\equiv u_{x,x} &amp;= (\\sigma _{xx} - \\nu \\sigma _{yy} - \\nu \\sigma _{zz})/E \\\\ \\label{eq:platehooke2} \\varepsilon _{yy} \\equiv u_{y,y} &amp;= (\\sigma _{yy} - \\nu \\sigma _{xx} - \\nu \\sigma _{zz})/E \\\\ \\label{eq:platehooke3} 2\\varepsilon _{xz} \\equiv u_{x,z} + u_{z,x} &amp;= 2(1+\\nu )\\tau _{xz}/E \\\\ \\label{eq:platehooke4} 2\\varepsilon _{yz} \\equiv u_{y,z} + u_{z,y} &amp;= 2(1+\\nu )\\tau _{yz}/E \\\\ \\label{eq:platehooke5} 2\\varepsilon _{xy} \\equiv u_{x,y} + u_{y,x} &amp;= 2(1+\\nu )\\tau _{xy}/E, \\end{align} . and taking the derivative of Eq. \\eqref{eq:platehooke3} with respect to \\(x\\) and of Eq. \\eqref{eq:platehooke4} with respect to \\(y\\), we obtain \\begin{align} \\label{eq:ux1} u_{x,xz} + u_{z,xx} &amp;= 2(1+\\nu )\\tau _{xz,x}/E \\\\ \\label{eq:uy1} u_{y,yz} + u_{z,yy} &amp;= 2(1+\\nu )\\tau _{yz,y}/E \\end{align} . and \\begin{align} \\label{eq:ux2} u_{x,xz} + u_{z,xx}=\\partial _z( u_{x,x}) + u_{z,xx}&amp;=u_{z,xx} + (\\sigma _{xx,z} - \\nu \\sigma _{yy,z} - \\nu \\sigma _{zz,z})/E \\\\ \\label{eq:uy2} u_{y,yz} + u_{z,yy}=\\partial _z( u_{y,y}) + u_{z,yy}&amp;=u_{z,yy} + (\\sigma _{yy,z} - \\nu \\sigma _{xx,z} - \\nu \\sigma _{zz,z})/E. \\end{align} . Combining Eqs. \\eqref{eq:ux1}, \\eqref{eq:ux2} and Eqs. \\eqref{eq:uy1}, \\eqref{eq:uy2} and noting that \\(\\sigma _{zz,z}=-\\tau _{xz,x}-\\tau _{xz,y}\\) yields \\begin{align} u_{z,xx} &amp;= \\left [(2+\\nu )\\tau _{xz,x} - \\nu \\tau _{yz,y} - \\sigma _{xx,z} + \\nu \\sigma _{yy,z} \\right ]/E \\\\ u_{z,yy} &amp;= \\left [(2+\\nu )\\tau _{yz,y} - \\nu \\tau _{xz,x} - \\sigma _{yy,z} + \\nu \\sigma _{xx,z}\\right ]/E. \\end{align} . We now create linear combination of these expressions such that \\(\\sigma _{xx,z}=M_{xx}/I\\) or \\(\\sigma _{yy,z}=M_{yy}/I\\) drop out, \\begin{align} u_{z,xx} + \\nu u_{z,yy} &amp;= \\left [(2+\\nu -\\nu ^2)\\tau _{xz,x} - \\nu (1+\\nu )\\tau _{yz,y} - (1-\\nu ^2)M_{xx}/I \\right ]/E \\\\ u_{z,yy} + \\nu u_{z,xx} &amp;= \\left [(2+\\nu -\\nu ^2)\\tau _{yz,y} - \\nu (1+\\nu )\\tau _{xz,x} - (1-\\nu ^2)M_{yy}/I \\right ]/E. \\end{align} . We now only consider the displacement at the surface, \\(w(x,y)\\equiv u_z(x,y,h/2)\\). Since the surfaces are traction free, all terms involving \\(\\tau _{xz}\\) and \\(\\tau _{yz}\\) vanish. Hence \\begin{align} \\label{eq:plateMxx} M_{xx} &amp;= -K (w_{,xx} + \\nu w_{,yy}) \\\\ \\label{eq:plateMyy} M_{yy} &amp;= -K (w_{,yy} + \\nu w_{,xx}) \\end{align} . with the flexural rigidity \\(K=EI/(1-\\nu ^2)=Eh^3/[12(1-\\nu ^2)]\\). Finally, we are looking for an expression for \\(M_{xy}=I\\tau _{xy,z}\\). We have from Eqs. \\eqref{eq:platehooke3}-\\eqref{eq:platehooke5}\\begin{equation} \\frac{2(1+\\nu )}{EI} M_{xy} = u_{x,yz} + u_{y,xz} = \\frac{2(1+\\nu )}{E} (\\tau _{xz,y} + \\tau _{yz,x}) - 2u_{z,xy}, \\end{equation} which yields \\begin{equation} \\label{eq:plateMxy} M_{xy} = -K(1-\\nu ) w_{,xy}, \\end{equation} the desired expression. We now plug Eqs. \\eqref{eq:plateMxx}, \\eqref{eq:plateMyy} and \\eqref{eq:plateMxy} into the equilibrium conditions Eqs. \\eqref{eq:plateeq2} and \\eqref{eq:plateeq3}. This yields \\begin{align} -K(w_{,xxx} + w_{,xyy}) &amp;= Q_x(x, y) \\\\ -K(w_{,yyy} + w_{,xxy}) &amp;= Q_y(x, y) \\\\ -K(w_{,xxxx} + 2w_{,xxyy} + w_{,yyyy}) &amp;= -p(x, y). \\end{align} . The last expression is Kirchhoff’s equation, \\begin{equation} w_{,xxxx} + 2w_{,xxyy} + w_{,yyyy} = \\nabla ^2 \\nabla ^2 w = \\nabla ^4 w = \\frac{p}{K}, \\end{equation} that governs the deformation of plates. ",
    "url": "http://localhost:4000/_lecture/chapter10.html#x1-100010",
    "relUrl": "/_lecture/chapter10.html#x1-100010"
  },"28": {
    "doc": "Chapter 10",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter10.html#x1-400010.2",
    "relUrl": "/_lecture/chapter10.html#x1-400010.2"
  },"29": {
    "doc": "Chapter 10",
    "title": "Chapter 10",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter10.html",
    "relUrl": "/_lecture/chapter10.html"
  },"30": {
    "doc": "Chapter 11",
    "title": "Chapter 11Plastic failure",
    "content": "https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=febbdbb7-fd7e-4e98-8572-acb90150689c . ",
    "url": "http://localhost:4000/_lecture/chapter11.html#x1-100011",
    "relUrl": "/_lecture/chapter11.html#x1-100011"
  },"31": {
    "doc": "Chapter 11",
    "title": "Bibliography",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter11.html#x1-200011",
    "relUrl": "/_lecture/chapter11.html#x1-200011"
  },"32": {
    "doc": "Chapter 11",
    "title": "Chapter 11",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter11.html",
    "relUrl": "/_lecture/chapter11.html"
  },"33": {
    "doc": "Chapter 12",
    "title": "Chapter 12Brittle failure",
    "content": "12.1 Stress near a crack tip . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=e30ac1a6-b801-465b-aedf-acb9015b0c7d . 12.1.1 Airy stress function . First, we invoke Hooke’s law, Eq. \\eqref{eqn:Isotropic˙elasticity˙inverse}. Using Eq. \\eqref{eqn:planestrain˙stressyy} Hooke’s law itself becomes \\begin{align} \\label{eqn:Planestrain_Hookes} \\varepsilon _{xx} &amp;= \\frac{1}{E} [(1+\\nu )\\sigma _{xx} - \\nu (\\sigma _{xx} + \\sigma _{yy} + \\sigma _{zz})] = \\frac{1+\\nu }{E} [(1-\\nu )\\sigma _{xx} - \\nu \\sigma _{yy}] \\\\ \\varepsilon _{yy} &amp;= \\frac{1+\\nu }{E} [(1-\\nu )\\sigma _{yy} - \\nu \\sigma _{xx}] \\\\ \\varepsilon _{xy} &amp;= \\frac{1}{2G} \\sigma _{xy} = \\frac{1+\\nu }{E} \\sigma _{xy} \\end{align} . under plane strain conditions. We have just eliminated reference to \\(\\sigma _{zz}\\) and \\(\\varepsilon _{zz}\\) from the equations. Inserting Hooke’s law into the compatibility condition, Eq. \\eqref{eqn:Compatibility˙eqn}, yields \\begin{equation} \\label{eqn:Compatibility_stresses} (1-\\nu ) \\left [\\frac{\\partial ^2 \\sigma _{xx}}{\\partial y^2} + \\frac{\\partial ^2 \\sigma _{yy}}{\\partial x^2}\\right ] - \\nu \\left [\\frac{\\partial ^2 \\sigma _{xx}}{\\partial x^2} + \\frac{\\partial ^2 \\sigma _{yy}}{\\partial y^2}\\right ] = 2 \\frac{\\partial ^2 \\sigma _{xy}}{\\partial x \\partial y}, \\end{equation} the compatibility condition for the stresses. We now use a mathematical trick to solve the equations of elastic equilibrium. We define the Airy stress function \\(\\phi (x,y)\\), that gives the stresses (in Cartesian coordinates) as \\begin{align} \\label{eqn:airyxx} \\sigma _{xx} &amp;= \\frac{\\partial ^2 \\phi }{\\partial y^2} \\equiv [\\nabla (\\nabla \\phi )]_{yy}, \\\\ \\label{eqn:airyzz} \\sigma _{yy} &amp;= \\frac{\\partial ^2 \\phi }{\\partial x^2} \\equiv [\\nabla (\\nabla \\phi )]_{xx},\\\\ \\label{eqn:airyxz} \\sigma _{xy} &amp;= -\\frac{\\partial ^2 \\phi }{\\partial x \\partial y} \\equiv [\\nabla (\\nabla \\phi )]_{xy} \\end{align} . (Note that the first \\(\\nabla \\) is the gradient of the vector field \\(\\nabla \\phi \\), not the divergence! Hence \\(\\nabla (\\nabla \\phi )\\) is a second order tensor with components \\([\\nabla (\\nabla \\phi )]_{ij}=\\phi _{,ij}\\)!) Equation \\eqref{eqn:planestrain˙elastic˙equixx} becomes \\begin{equation} \\label{eqn:elastic_equi_airy} \\frac{\\partial ^3 \\phi }{\\partial x \\partial y^2} - \\frac{\\partial ^3 \\phi }{\\partial x \\partial y^2} = 0 \\end{equation} and is automatically fulfilled! The same holds for Eq. \\eqref{eqn:planestrain˙elastic˙equizz} We can now insert Eqs. \\eqref{eqn:airyxx} to \\eqref{eqn:airyxz} into the compatibility condition Eq. \\eqref{eqn:Compatibility˙stresses} to give \\begin{equation} \\label{eqn:compatibility_airy} (1-\\nu )\\left [\\frac{\\partial ^2 }{\\partial y^2} \\frac{\\partial ^2 \\phi }{\\partial y^2} + \\frac{\\partial ^2 }{\\partial x^2} \\frac{\\partial ^2 \\phi }{\\partial x^2}\\right ] - \\nu \\left [\\frac{\\partial ^2 }{\\partial x^2} \\frac{\\partial ^2 \\phi }{\\partial y^2} + \\frac{\\partial ^2}{\\partial y^2} \\frac{\\partial ^2 \\phi }{\\partial x^2} \\right ] + 2 \\frac{\\partial ^2}{\\partial x \\partial y} \\frac{\\partial ^2 \\phi }{\\partial x \\partial y} = 0, \\end{equation} which can be rearranged to \\begin{equation} \\label{eqn:compatibility_airy_rearr} \\frac{\\partial ^4 \\phi }{\\partial x^4} + 2\\frac{\\partial ^4 \\phi }{\\partial x^2 \\partial y^2} + \\frac{\\partial ^4 \\phi }{\\partial y^4} = \\left (\\frac{\\partial ^2}{\\partial x^2} + \\frac{\\partial ^2}{\\partial y^2}\\right )\\left [\\left (\\frac{\\partial ^2}{\\partial x^2} + \\frac{\\partial ^2}{\\partial y^2}\\right ) \\phi \\right ] = \\nabla ^4 \\phi = 0 \\end{equation} Conditions \\eqref{eqn:planestrain˙elastic˙equixx} to \\eqref{eqn:Compatibility˙eqn} are all simultaneously fulfilled if Eq. \\eqref{eqn:compatibility˙airy˙rearr} is fulfilled! Equation \\eqref{eqn:compatibility˙airy˙rearr} is the compatibility condition, but expressed for the Airy stress function. The operator \\(\\nabla ^4\\) is called the biharmonic operator and any function \\(\\phi \\) satifying \\(\\nabla ^4 \\phi =0\\) is called a biharmonic function. (Functions \\(\\phi \\) that fulfill the Laplace equation \\(\\nabla ^2\\phi =0\\) are called harmonic functions.) The derivation above tells us, that for isotropic elasticity a biharmonic Airy stress \\(\\phi (x,y)\\) automatically leads to a compatible strain field. This means for any biharmonic function \\(\\phi (x,y)\\), the stress field derived from Eqs. \\eqref{eqn:airyxx}-\\eqref{eqn:airyxz} will describe a system in static equilibrium. The only thing left to do is to find the function \\(\\phi (x,y)\\) that fulfills a specific boundary condition. 12.1.2 Westergaard stress function . The Westergaard stress function builds on top of the Airy function and eliminates the need to even satisfy the biharmonic equation \\(\\nabla ^4\\phi =0\\). This means that for any choice of the Westergaard stress function, the conditions for force and moment equilibrium and the compatibility condition are fulfilled automatically. The Westergaard stress function can then be chosen freely as to fulfill the boundary conditions of the problem. Westergaard (1933) introduced a function \\(Z(z)\\) that is now known as the Westergaard stress function. Note that here \\(z\\) is a complex variable that contains the \\(x\\) and \\(y\\)-position as its real and imaginary part, \\(z=x+iy\\), and not the \\(z\\)-coordinate. Likewise, the function \\(Z(z)\\) is complex valued. Following common notation, we denote its integrals by \\begin{equation} \\bar{\\bar{Z}}_{,z} = \\bar{Z} \\quad \\text{and}\\quad \\bar{Z}_{,z} = Z. \\end{equation} Westergaard defined the Airy stress function as \\begin{equation} \\label{eqn:Westergaard} \\phi (x, y) = \\Re \\left \\{\\bar{\\bar{Z}}(x+iy)\\right \\} + y \\Im \\left \\{\\bar{Z}(x+iy)\\right \\} \\end{equation} where \\(\\Re \\) and \\(\\Im \\) denote the real and imaginary part of a complex number, respectively. This Airy stress function fulfills the biharmonic equation, Eq. \\eqref{eqn:compatibility˙airy˙rearr}, for any arbitrary function \\(Z(z)\\), as we will show below. We will now derive the expressions for the stresses. We first note that since \\(Z(z)\\) is a function of a complex variable, it satisfies the Cauchy-Riemann conditions, \\begin{align} \\Re Z_{,z} &amp;= \\left (\\Re Z\\right )_{,x} = \\left (\\Im Z\\right )_{,y} \\\\ \\Im Z_{,z} &amp;= \\left (\\Im Z\\right )_{,x} = -\\left (\\Re Z\\right )_{,y}, \\end{align} . which implies that \\begin{align} \\label{eqn:laplaceRe} \\nabla ^2 \\left (\\Re Z\\right ) &amp;= \\left (\\Re Z\\right )_{,xx} + \\left (\\Re Z\\right )_{,yy} = 0 \\\\ \\nabla ^2 \\left (\\Im Z\\right ) &amp;= \\left (\\Im Z\\right )_{,xx} + \\left (\\Im Z\\right )_{,yy} = 0, \\\\ \\end{align} . i.e. the real and imaginary parts of the complex function \\(Z(z)\\) fulfill the Laplace equation. Note: Cauchy-Riemann equations – The Cauchy-Riemann equations are a cornerstone of complex analysis. They hold for any differential function of a complex variable. Such functions are also called holomorphic. Given \\(f(z)=u(z) + iv(z)\\) (hence \\(u=\\Re f\\) and \\(v=\\Im f\\)) with \\(z=x+iy\\), we can formally write the derivative as \\begin{equation} f'(z_0) = \\lim \\limits _{w\\in \\mathcal{C},w\\to 0} \\frac{f(z_0+w)-f(z_0)}{w} \\end{equation} as the limit of the difference quotient. For real numbers, we can approach \\(z_0\\) from the left or the right and both limits must equal if the function is differentiable. In the complex plane, we can approach from any direction in two dimensions. For example, we can compute the derivative along the real (\\(x\\)-)axis, \\(w=x\\): \\begin{equation} f'(z_0) = \\lim \\limits _{x\\in \\mathcal{R},x\\to 0} \\frac{f(z_0+x)-f(z_0)}{x} = \\frac{\\partial u}{\\partial x} + i\\frac{\\partial v}{\\partial x} \\end{equation} We can equally well compute the derivative along the imaginary (\\(y\\)-)axis, \\(w=iy\\), which gives \\begin{equation} f'(z_0) = \\lim \\limits _{y\\in \\mathcal{R},y\\to 0} \\frac{f(z_0+iy)-f(z_0)}{iy} = -i\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial y}. \\end{equation} Since both expressions have to be equal, we find \\begin{equation} \\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\quad \\text{and}\\quad \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x}, \\end{equation} the Cauchy-Riemann equations. Now we differentiate \\(\\phi \\) with respect to \\(x\\) and \\(y\\). This yields \\begin{align} \\phi _{,x} &amp;= \\left (\\Re \\bar{\\bar{Z}}\\right )_{,x} + y\\left (\\Im \\bar{Z}\\right )_{,x} = \\Re \\bar{\\bar{Z}}_{,z} + y \\Im \\bar{Z}_{,z} = \\Re \\bar{Z} + y \\Im Z \\\\ \\phi _{,y} &amp;= \\left (\\Re \\bar{\\bar{Z}}\\right )_{,y} + \\left (y \\Im \\bar{Z}\\right )_{,y} = -\\Im \\bar{\\bar{Z}}_{,z} + \\Im \\bar{Z} + y \\Re \\bar{Z}_{,z} = y \\Re Z \\end{align} . for the first derivatives and \\begin{align} \\phi _{,xx} &amp;= \\left (\\Re \\bar{Z}\\right )_{,x} + y \\left (\\Im Z\\right )_{,x} = \\Re \\bar{Z}_{,z} + y \\Im Z_{,z} = \\Re Z + y \\Im Z_{,z} \\\\ \\phi _{,yy} &amp;= \\left (y\\Re Z\\right )_{,y} = \\Re Z + y \\left (\\Re Z\\right )_{,y} = \\Re Z - y \\Im Z_{,z} \\\\ \\phi _{,xy} &amp;= \\left (\\Re \\bar{Z}\\right )_{,y} + \\left (y \\Im Z\\right )_{,y} = -\\Im \\bar{Z}_{,z} + \\Im Z + y \\Re Z_{,z} = y \\Re Z_{,z} \\end{align} . for the second derivatives. In summary, we obtain \\begin{align} \\label{eqn:Westergaardstressxx} \\sigma _{xx} &amp;= \\phi _{,yy} = \\Re Z - y \\Im Z_{,z} \\\\ \\label{eqn:Westergaardstressyy} \\sigma _{yy} &amp;= \\phi _{,xx} = \\Re Z + y \\Im Z_{,z} \\\\ \\label{eqn:Westergaardstresszz} \\sigma _{xy} &amp;= -\\phi _{,xy} = -y \\Re Z_{,z} \\end{align} . for the components of the stress tensor. Note that the Ansatz Eq. \\eqref{eqn:Westergaard} fulfills the biharmonic equation. We know from summing Eqs. \\eqref{eqn:Westergaardstressxx} and \\eqref{eqn:Westergaardstressyy} that \\begin{equation} \\psi \\equiv \\left (\\frac{\\partial ^2}{\\partial x^2} + \\frac{\\partial ^2}{\\partial y^2}\\right )\\phi = 2\\Re Z, \\end{equation} hence by virtue of Eq. \\eqref{eqn:laplaceRe}, \\(\\nabla ^4\\phi =\\nabla ^2\\psi =0\\) is fulfilled for any function \\(Z(x+iy)\\). The utility of the Westergaard function over the Airy stress function is hence that we have eliminated the need to explicitly fulfill the biharmonic equation. 12.1.3 Stress field . We here discuss only mode I fracture, i.e. crack opening displacement. Consider a plane (strain or stress) situation in which we can derive the stress field from the Westergaard stress function \\(Z(x+iy)\\), Sec. 12.1.2. Westergaard (1933) made the Ansatz \\begin{equation} Z(z) = \\frac{\\sigma _\\infty }{\\sqrt{1 - (a/z)^2}} \\end{equation} for the stress function of a central crack in a large sheet. Here \\(2a\\) is the length of the crack and \\(\\sigma _\\infty \\) the stress at infinity. The derivative of the stress function is \\begin{equation} \\label{eqn:Westergaard_derivative} Z_{,z} = \\frac{\\sigma _\\infty }{\\sqrt{z^2 - a^2}} \\left [ 1 - \\frac{1}{1-(a/z)^2} \\right ] \\end{equation} and its integral is \\begin{equation} \\label{eqn:Westergaard_integral} \\bar{Z} = \\sigma _\\infty \\sqrt{z^2 - a^2}. \\end{equation} . Let us first look in the plane of the crack where \\(y=0\\), \\(z=x\\) and hence \\begin{equation} Z(x) = \\frac{\\sigma _\\infty }{\\sqrt{1 - (a/x)^2}}. \\end{equation} For \\(|x|&lt;a\\) (inside the crack) the function is imaginary but for \\(|x|&gt;a\\) (outside the crack) the function is real. The stresses in the plane of the crack are given by \\(\\sigma _{xx}=\\Re Z\\), \\(\\sigma _{yy}=\\Re Z\\) and \\(\\tau _{xy}=0\\). Hence they vanish inside the crack. This is the condition for the crack faces which are free surfaces and therefore tractionless. Note that \\(\\sigma _{xx}\\) does not need to vanish from this condition but does here. Outside the crack (but in the plane of the crack, \\(y=0\\)), the stress is given by \\begin{equation} \\sigma _{xx} = \\sigma _{yy} = \\frac{\\sigma _\\infty }{\\sqrt{1 - (a/x)^2}}. \\end{equation} It diverges as \\(x\\to a\\) from above and approaches the hydrostatic state \\(\\sigma _{xx}=\\sigma _{yy}=\\sigma _\\infty \\) as \\(x\\to \\infty \\). We will now focus on the crack line and switch to the variable \\(z^*=z-a\\). The stress function becomes \\begin{equation} Z(z^*) = \\frac{\\sigma _\\infty (z^*+a)}{\\sqrt{(z^* + a)^2 - a^2}} = \\frac{\\sigma _\\infty (z^*+a)}{\\sqrt{(z^*)^2 + 2az^*}} \\approx \\sigma _\\infty \\sqrt{\\frac{a}{2z^*}} \\end{equation} where the \\(\\approx \\) sign is valid for small \\(z^*\\). We write this expression as \\begin{equation} \\label{eqn:stress_intensity} Z(z^*) = \\frac{K_I}{\\sqrt{2\\pi z^*}} \\quad \\text{with}\\quad K_I = \\sigma _\\infty \\sqrt{\\pi a}. \\end{equation} Note that we have absorbed both the stress at infinity \\(\\sigma _\\infty \\) and the crack length \\(a\\) into a single constant, the stress intensity factor (for mode I fracture), \\(K_I\\). The stress field near the crack tip depends only on \\(K_I\\), not on \\(\\sigma _\\infty \\) and \\(a\\) individually and hence the loading condition and geometry, independently. To derive the component of the stress tensor, we switch to cylindrical coordinates and write \\(z^*=r e^{i\\theta }\\), yielding \\begin{equation} Z(r, \\theta ) = \\frac{K_I}{\\sqrt{2\\pi r}} e^{-i\\theta /2}. \\end{equation} In order to obtain the full stress field, we also need the expression for the derivative of the Westergaard stress function near the crack tip. From Eq. \\eqref{eqn:Westergaard˙derivative}, we find \\begin{equation} Z_{,z} \\approx \\frac{\\sigma _\\infty }{\\sqrt{2az^*}} \\left [ 1-\\frac{2az^* + a^2}{2az^*} \\right ] = -\\frac{\\sigma _\\infty a^2}{(2az^*)^{3/2}} = -\\frac{K_I \\pi }{(2\\pi z^*)^{3/2}} = -\\frac{K_I}{\\sqrt{8\\pi r}} e^{-3i\\theta /2}. \\end{equation} We now obtain the individual components of the stress tensor from Eq. \\eqref{eqn:Westergaardstressxx}-\\eqref{eqn:Westergaardstresszz}: \\begin{align} \\sigma _{xx} &amp;= \\Re Z - y \\Im Z_{,z} = \\frac{K_I}{\\sqrt{2\\pi r}} \\cos \\frac{\\theta }{2} \\left (1 - \\sin \\frac{\\theta }{2} \\sin \\frac{3\\theta }{2}\\right ) \\\\ \\sigma _{yy} &amp;= \\Re Z + y \\Im Z_{,z} = \\frac{K_I}{\\sqrt{2\\pi r}} \\cos \\frac{\\theta }{2} \\left (1 + \\sin \\frac{\\theta }{2} \\sin \\frac{3\\theta }{2}\\right ) \\\\ \\sigma _{xy} &amp;= -y \\Re Z_{,z} = \\frac{K_I}{\\sqrt{2\\pi r}} \\cos \\frac{\\theta }{2} \\sin \\frac{\\theta }{2} \\cos \\frac{3\\theta }{2} \\end{align} . Hence the stress field near the crack tip is entirely described by the stress intensity factor \\(K_I\\). \\(K_I\\) is measured in (weird) units of Pa\\(\\sqrt{\\text{m}}\\). The \\(I\\) indicates that this is the stress intensity factor for mode \\(I\\) fracture. \\(K_{II}\\) and \\(K_{III}\\) are related quatities for the two other fracture modes. Note that the stress intensity factor is the amplitude of the square-root singularity of the stress field at the crack tip. It is often defined from the stress field itself as the limit \\begin{align} \\label{eq:KI} K_I &amp;= \\lim \\limits _{r\\to 0} \\sqrt{2\\pi r} \\sigma _{yy}(r, 0) \\\\ \\label{eq:KII} K_{II} &amp;= \\lim \\limits _{r\\to 0} \\sqrt{2\\pi r} \\sigma _{xy}(r, 0) \\\\ \\label{eq:KIII} K_{III} &amp;= \\lim \\limits _{r\\to 0} \\sqrt{2\\pi r} \\sigma _{yz}(r, 0), \\\\ \\end{align} . where the singularity has been removed by multiplying with \\(\\sqrt{2\\pi r}\\). Note that the limit is taken at the angle \\(\\theta =0\\), i.e. along \\(y=0\\) within the plane of the crack. From Eqs. \\eqref{eq:KI} to \\eqref{eq:KIII} is also clear that only \\(K_I\\) is nonzero for the crack geometry that is discussed in this chapter. 12.2 Fracture toughness . https://uni-freiburg.cloud.panopto.eu/Panopto/Pages/Embed.aspx?id=993c55f0-a6d5-4df9-a1ff-acb9015f614e . 12.2.1 Displacement field at the crack tip . In order to compute the displacement field near the crack, we first need the strain field. As usual, we obtain this from Hooke’s law (in plain stress): \\begin{align} \\label{eqn:crackstrainxx} \\varepsilon _{xx} &amp;\\equiv u_{x,x} = \\frac{1}{E}\\left (\\sigma _{xx} - \\nu \\sigma _{yy}\\right ) = \\frac{1}{E}\\left [(1-\\nu ) \\Re Z - (1+\\nu ) y \\Im Z_{,z}\\right ] \\\\ \\label{eqn:crackstrainyy} \\varepsilon _{yy} &amp;\\equiv u_{y,y} = \\frac{1}{E}\\left (\\sigma _{yy} - \\nu \\sigma _{xx}\\right ) = \\frac{1}{E}\\left [(1-\\nu ) \\Re Z + (1+\\nu ) y \\Im Z_{,z}\\right ] \\\\ \\label{eqn:crackstrainxy} 2\\varepsilon _{xy} &amp;\\equiv u_{x,y}+u_{y,x} = 2\\frac{1+\\nu }{E} \\sigma _{xy} = -2\\frac{1+\\nu }{E} y \\Re Z_{,z} \\end{align} . Now we use \\(Z=\\bar{Z}_{,z}\\) to express \\(\\Re Z = \\Re \\bar{Z}_{,z} = (\\Re \\bar{Z})_{,x}\\) and \\(\\Im Z_{,z}=(\\Im Z)_{,x}\\) in Eq. \\eqref{eqn:crackstrainxx} to identify \\begin{equation} u_x = \\frac{1}{E}\\left [(1-\\nu ) \\Re \\bar{Z} - (1+\\nu ) y \\Im Z\\right ] =\\frac{1}{2\\mu }\\left [\\frac{1-\\nu }{1+\\nu } \\Re \\bar{Z} - y \\Im Z\\right ]. \\end{equation} The expression for \\(u_y\\) is more complicated because of the explicit \\(y\\) that shows up in the expressions for the strains. It is given by \\begin{equation} u_y = \\frac{1}{2\\mu }\\left [\\frac{2}{1+\\nu } \\Im \\bar{Z} - y \\Re Z\\right ]. \\end{equation} It is straightforward to verify that from these two expressions we also recover the expression for \\(\\varepsilon _{xy}\\). It is common to replace \\(\\nu \\) with \\(\\kappa =(3-\\nu )/(1+\\nu )\\). The displacements can then be written as \\begin{align} u_x &amp;= \\frac{1}{4\\mu }\\left [(\\kappa -1) \\Re \\bar{Z} - 2y \\Im Z\\right ] \\\\ u_y &amp;= \\frac{1}{4\\mu }\\left [(\\kappa +1) \\Im \\bar{Z} - 2y \\Re Z\\right ]. \\end{align} . Since the integral of the Westergaard function near the crack tip is \\begin{equation} \\bar{Z}(z^*) \\approx \\sigma _\\infty \\sqrt{2 a z^*} = K_I \\sqrt{\\frac{2 z^*}{\\pi }} = 2K_I \\sqrt{\\frac{r}{2\\pi }} e^{i\\theta /2}, \\end{equation} we can directly write the displacement field in cylindrical coordinates as \\begin{align} u_x &amp;= \\frac{K_I}{2\\mu } \\sqrt{\\frac{r}{2\\pi }} \\left [ 2\\frac{1-\\nu }{1+\\nu } \\cos \\frac{\\theta }{2} + \\sin ^2 \\frac{\\theta }{2} \\right ]\\\\ u_y &amp;= \\frac{K_I}{2\\mu } \\sqrt{\\frac{r}{2\\pi }} \\left [ 2\\frac{1-\\nu }{1+\\nu } \\cos \\frac{\\theta }{2} + \\sin ^2 \\frac{\\theta }{2} \\right ]. \\end{align} . Note that in the plane of the crack (\\(y=0\\), \\(z^*=x\\)), the displacement field is given by \\begin{align} u_x &amp;= \\begin{cases} \\frac{K_I}{2\\mu } (\\kappa -1) \\sqrt{\\frac{x}{2\\pi }} &amp; \\text{if}\\;x &gt; 0 \\\\ 0 &amp; \\text{if}\\;x \\leq 0 \\end{cases}\\\\ u_y^+ &amp;= \\begin{cases} 0 &amp; \\text{if}\\;x \\geq 0 \\\\ \\frac{K_I}{2\\mu } (\\kappa +1) \\sqrt{-\\frac{x}{2\\pi }} &amp; \\text{if}\\;x &lt; 0 \\end{cases}. \\label{eq:displyat0} \\end{align} . The \\(y\\)-displacement here is denoted with a little \\(+\\), \\(u_y^+\\), to indicate that this is the displacement of the top crack face at a position \\(y=0^+\\), i.e. slightly above \\(y=0\\). The displacement \\(u_y^-\\) of the bottom crack face is the negative of this values, \\(u_y^-=-u_y^+\\), for symmetry reasons. Mathematically, this property emerges because the square-root has a branch cut along the negative real axis. 12.2.2 Strain energy release rate . In order to formulate a fracture criterion we will require an expression for the elastic energy released during propagation of the crack. This will lead to the concept of the strain energy release rate. We have not yet talked about the concept of energy in this notes. Since elasticity is fully reversible (an elastic object returns to its origin shape when unloaded), the work carried out when deforming an elastic body is conservative. This means we can define an elastic energy that is recoverable by unloading the body. In order to define the energy release rate, we will here focus on the work \\(W\\) done by a moving crack. We first note that the crack faces do not contribute to the work because the normal stress is zero by definition, since we are dealing with a free surface. We therefore have to focus on the crack tip. The tip opens by the distance given by Eq. \\eqref{eq:displyat0} to both sides. This displacement work against the stress \\(\\sigma _{yy}\\) right at the crack tip. We now assume that the crack moves by a distance \\(\\Delta a\\) which we will later take to zero. We assume that the stress before the crack has moved is taken to zero quasistatically during the crack opening process. The crack faces have opened a distance \\begin{equation} u_y^+ - u_y^-=2\\frac{K_I}{2\\mu } (\\kappa + 1) \\sqrt{\\frac{\\Delta a - x^*}{2\\pi }} \\end{equation} after the crack has moved by \\(\\Delta a\\). The stress was \\begin{equation} \\sigma _{yy}=\\frac{K_I}{\\sqrt{2\\pi x^*}} \\end{equation} before the movement of the crack. The work on the crack faces is then \\(W=\\int dx^* \\sigma _{yy} (u_y^+-u_y^-)/2\\). (The factor \\(1/2\\) enters because we are taking the stress to zero as the crack faces are displacing. Imagine a simple spring with force \\(f=kx\\) taken from \\(x_0\\) to \\(x=0\\). The work is \\(kx_0^2/2\\), equal to the elastic energy of the string at extension \\(x_0\\).) This gives \\begin{equation} W(\\Delta a) = \\frac{K_I^2}{4\\pi \\mu } (\\kappa + 1) \\int \\limits _0^{\\Delta a} dx^* \\sqrt{\\frac{\\Delta a - x^*}{x^*}} = \\frac{K_I^2}{\\mu } \\frac{\\kappa +1}{8} \\Delta a = \\frac{K_I^2}{E} \\Delta a \\end{equation} where we have used \\(\\int _0^1 dx \\sqrt{(1-x)/x}=\\pi /2\\). The energy released per crack length is then \\begin{equation} G = \\frac{W}{\\Delta a} = \\frac{K_I^2}{E}. \\label{eq:energyreleaserate} \\end{equation} \\(G\\) is called the strain energy release rate and has units of energy per area. Note that Eq. \\eqref{eq:energyreleaserate} is valid for a state of plain strain, which has entered through Hooke’s law in Eqs. \\eqref{eqn:crackstrainxx} to \\eqref{eqn:crackstrainxy}. 12.3 Griffith’s fracture criterion . The value of \\(K_I\\) uniquely defines the stress field near the crack tip and therefore determines when the crack advances. We define a critical \\(K_{Ic}\\) beyond which the crack becomes unstable and a new crack opens when \\(K_I&gt;K_{Ic}\\). \\(K_{Ic}\\) is called the fracture toughness. Generally, \\(K_I\\) depends on crack geometry and loading condition. For the example worked above, a straight crack of length \\(a\\) in an infinite isotropic medium we get Eq. \\eqref{eqn:stress˙intensity}. We see that the stress intensity factor \\(K_I\\) growth with crack length \\(a\\); hence there is a critical length \\(a_c\\) beyond which the crack becomes unstable. As the crack advances it creates new surface area. An advance of the crack from length \\(a\\) to length \\(a+\\Delta a\\) requires the additional energy \\(\\Delta E_{\\text{surf}}=2\\gamma \\Delta a\\). Here, \\(\\gamma \\) is the surface energy of the pristine crack surface and the factor of \\(2\\) enters because a crack has two faces. Since we are looking at a plane situation, \\(\\Delta E_{\\text{surf}}\\) is an energy per unit length. Griffith’s fracture criterion now states that the crack advances when the energy released from the elastic field (described by the strain energy release rate \\(G\\)) is larger than the energy needed to create a new surface, \\begin{equation} G&gt;G_c \\end{equation} where \\(G_c\\) is Griffith’s critical energy release rate. For an ideal brittle crack, \\begin{equation} G_c=2\\gamma , \\end{equation} because we only need to “pay” for the new surface with elastic energy. This allows us to define a fracture toughness, \\(K_{Ic}=\\sqrt{E G_c}\\), from Griffith’s theory. ",
    "url": "http://localhost:4000/_lecture/chapter12.html#x1-100012",
    "relUrl": "/_lecture/chapter12.html#x1-100012"
  },"34": {
    "doc": "Chapter 12",
    "title": "Bibliography",
    "content": "   H. M. Westergaard. Stresses at a crack, size of the crack, and the bending of reinforced concrete. Journal Proceedings, 30(11), 1933. doi: 10.14359/8300. ",
    "url": "http://localhost:4000/_lecture/chapter12.html#x1-1000012.3",
    "relUrl": "/_lecture/chapter12.html#x1-1000012.3"
  },"35": {
    "doc": "Chapter 12",
    "title": "Chapter 12",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter12.html",
    "relUrl": "/_lecture/chapter12.html"
  },"36": {
    "doc": "Kapitel 13",
    "title": "Kapitel 13Nichtlineare Probleme",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter13.html#x1-100013",
    "relUrl": "/_lecture/chapter13.html#x1-100013"
  },"37": {
    "doc": "Kapitel 13",
    "title": "Literaturverzeichnis",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter13.html#x1-200013",
    "relUrl": "/_lecture/chapter13.html#x1-200013"
  },"38": {
    "doc": "Kapitel 13",
    "title": "Kapitel 13",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter13.html",
    "relUrl": "/_lecture/chapter13.html"
  },"39": {
    "doc": "Kapitel 14",
    "title": "Kapitel 14Unstrukturierte Gitter",
    "content": "Kontext: Wir zeigen hier wir die Methode der finiten Elemente für zweidimensionale unstrukturierte Gitter umgesetzt wird. Hierzu bauen wir auf den Ergebnissen der vorhergehenden Kapiteln auf und führen die Koordinatentransformation mit Hilfe der Jacobi-Matrix ein. 14.1 Koordinatentransformation . Wir betrachten nun den Fall, in dem unser Gitter nicht mehr strukturiert ist. Wir brauchen in diesem Fall explizit die Positionen der Knoten \\(\\v{r}_i\\) als zusätzliche Information. Die Elemente sind dann durch drei Knotenindices beschrieben. Beim Aufbau der entsprechenden Datenstrukturen ist natürlich zu beachten, dass Elemente beispielsweise nicht überlappen und das gesamte Simulationsgebiet trianguliert ist. Wir werden im folgenden den Elementindex \\((n)\\) nicht explizit an alle Gleichungen schreiben, die Ausdrücke gelten aber pro Element. Ein Element wird nun mit drei Knotenposition \\(\\v{r}_0\\), \\(\\v{r}_1\\) und \\(\\v{r}_2\\) beschrieben, wobei die Indices hier die lokalen Knotenindices beschreiben. Die normierten Koordinaten \\(\\xi \\) und \\(\\eta \\) beschreiben nun die Position in inneren dieses Elements. Insbesondere ist Knoten \\(0\\) durch \\((\\xi , \\eta )=(0,0)\\), Knoten \\(1\\) durch \\((\\xi , \\eta )=(1,0)\\) und Knoten \\(2\\) durch \\((\\xi , \\eta )=(0,1)\\) in normierten Koordinaten gegeben. Wir bilden nun die normierten Koordinaten auf reale Koordinaten durch eine affine Abbildung ab, \\begin{equation} \\v{r} = \\v{r}_0 + \\xi (\\v{r}_1-\\v{r}_0) + \\eta (\\v{r}_1-\\v{r}_0), \\end{equation} wobei das Dreieck durch die Vektoren \\(\\v{R}_1=\\v{r}_1-\\v{r}_0\\) und \\(\\v{R}_2=\\v{r}_2-\\v{r}_0\\) aufgespannt wird (siehe Abb. 14.1). Abbildung 14.1:: Illustration eines Dreiecks mit den normierten Koordinaten \\(\\xi \\) und \\(\\eta \\). Die Ecken des Dreiecks sind durch die Vektoren \\(\\v{r}_0\\), \\(\\v{r}_1\\) und \\(\\v{r}_2\\) gegeben. Für die Jacobi-Matrix brauchen wir nun Ableitungen der Form \\(\\partial x/\\partial \\xi \\), wobei \\((x,y)=\\v{r}\\) die Position innerhalb des Elements bezeichnet: \\begin{equation} \\t{J} = \\begin{pmatrix} \\partial x/\\partial \\xi &amp; \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi &amp; \\partial y/\\partial \\eta \\end{pmatrix} = \\begin{pmatrix} \\v{R}_1 &amp; \\v{R}_2 \\end{pmatrix} \\end{equation} Das inverse der Jacobi-Matrix können wir schreiben als \\begin{equation} \\t{J}^{-1} = \\begin{pmatrix} \\v{G}_1 &amp; \\v{G}_2 \\end{pmatrix}^T, \\end{equation} wobei \\(\\v{R}_i\\cdot \\v{G}_j=\\delta _{ij}\\). Die \\(\\v{G}_i\\) sind die reziproken Vektoren zu \\(\\v{R}_i\\), \\begin{align} \\v{G}_1 &amp;= \\frac{1}{R_{11}R_{22}-R_{12}^2} \\\\ \\v{G}_2 &amp;= \\frac{1}{R_{11}R_{22}-R_{12}^2} \\end{align} . Mit Hilfe der Jacobi-Matrix können wir nun Gradienten, \\begin{equation} \\nabla \\cdot \\t{J} = \\hat{\\nabla }, \\end{equation} mit Hilfe des normierten Gradientens, \\(\\hat{\\nabla }=(\\partial /\\partial \\xi , \\partial /\\partial \\eta )\\), ausdrücken. Die Skalarprodukte werden zu \\begin{equation} \\begin{split} (f,g) &amp;= \\int \\dif x\\dif y\\, f^*(x,y)g(x,y) \\\\ &amp;= |\\det \\t{J}| \\int \\dif \\xi \\dif \\eta \\, f^*(\\xi ,\\eta )g(\\xi ,\\eta ) \\end{split} \\label{eq:coordinate-transform-scalar-product} \\end{equation} Man beachte, dass die letzte Identität in Gl. \\eqref{eq:coordinate-transform-scalar-product} nur gilt, wenn \\(\\t{J}\\) konstant ist. Dies ist aber für die Transformation hier der Fall. Weiterhin ist die Jacobi-Determinate (engl. “Jacobian”) das doppelte der Fläche \\(A\\) des entsprechenden Dreiecks, \\(\\det \\t{J}=2A\\). 14.2 Elementmatrix . 14.2.1 Laplace-Operator . Wir betrachten nun die Elementmatrix für den Laplace-Operator, \\begin{equation} \\begin{split} K_{IJ} &amp;= (\\nabla N_I, \\nabla N_J), \\\\ &amp;= \\det \\t{J} \\int \\dif \\xi \\dif \\eta \\, \\hat{\\nabla }N_I \\cdot \\t{J}^{-1} \\cdot \\left [\\t{J}^{-1}\\right ]^T \\cdot \\hat{\\nabla } N_J, \\end{split} \\end{equation} wobei \\begin{equation} \\t{J}^{-1} \\cdot \\left [\\t{J}^{-1}\\right ]^T = \\begin{pmatrix} \\v{G}_1\\cdot \\v{G}_1 &amp; \\v{G}_1\\cdot \\v{G}_2 \\\\ \\v{G}_1\\cdot \\v{G}_2 &amp; \\v{G}_2\\cdot \\v{G}_2 \\end{pmatrix} \\end{equation} Skalarprodukte der reziproken Vektoren einhält. Für orthogonale \\(\\v{R}_i\\) sind auch die reziproken Vektoren orthogonal und \\(\\t{J}^{-1} \\cdot \\left [\\t{J}^{-1}\\right ]^T\\) wird eine Diagonalmatrix. und der Gradient im Sinne der normierten Koordinaten ausgeführt wird. Man erhält für den Laplace-Operator \\begin{equation} \\hat{\\t{K}} = \\begin{pmatrix} 1 &amp; -1/2 &amp; -1/2 \\\\ -1/2 &amp; 1/2 &amp; 0 \\\\ -1/2 &amp; 0 &amp; 1/2 \\end{pmatrix} \\label{eq:elmat2d} \\end{equation} . ",
    "url": "http://localhost:4000/_lecture/chapter14.html#x1-100014",
    "relUrl": "/_lecture/chapter14.html#x1-100014"
  },"40": {
    "doc": "Kapitel 14",
    "title": "Literaturverzeichnis",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter14.html#x1-500014.2.1",
    "relUrl": "/_lecture/chapter14.html#x1-500014.2.1"
  },"41": {
    "doc": "Kapitel 14",
    "title": "Kapitel 14",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter14.html",
    "relUrl": "/_lecture/chapter14.html"
  },"42": {
    "doc": "Kapitel 15",
    "title": "Kapitel 15Festkörpermechanik",
    "content": "Kontext: Die Methode der finiten Elementen hat ihren Ursprung in der Festkörpermechanik (auch Strukturmechanik). So gut wie alle Simulationen in diesem Bereich werden weiterhin mit Hilfe diese Methode durchgeführt. In diesem Kapitel werden wir die Grundgleichungen des elastostatischen Gleichgewichts diskretisieren, die eine Form haben die dem in den vorherigen Kapiteln diskutierten Transportproblem ähnlich sind. 15.1 Elastostatisches Gleichgewicht . Die Grundgleichung der Festkörpermechanik beschreibt das elastostatische Gleichgewicht. Gegeben ein Tensorfeld \\(\\t{\\sigma }(\\v{r})\\), dass die mechanische Spannung im System beschreibt, lauten diese \\begin{equation} \\nabla \\cdot \\t{\\sigma } = 0 \\label{eq:elastostaticeq} \\end{equation} Wir berechnen nun die Divergenz eines Tensors zweiter Ordnung (bzw. einen Tensorfeldes zweiter Ordnung) und müssen kurz klarstellen, was wir mit der Operation \\(\\nabla \\cdot =\\text{div}\\) meinen. In Komponentenschreibweise wird Gl. \\eqref{eq:elastostaticeq} zu \\begin{equation} \\partial _i \\sigma _{ij} = 0, \\end{equation} wobei \\(\\partial _i\\equiv \\partial /\\partial r_i\\) die Ableitung respektive der Komponente der Position \\(r_i\\) ist und wir hier die Einsteinsche Summenkonvention eingeführt haben. Diese Gleichgewichtsbedingung hat ihren Ursprung in der Erhaltung des Impulses; \\(\\t{\\sigma }\\) beschreibt drei unabhängige Impulsströme und Gl. \\eqref{eq:elastostaticeq} ist die stationäre Kontinuitätsgleichung, \\(\\nabla \\cdot \\v{j}=0\\), für diese drei Impulsströme die durch die Spaltenvektoren des Tensors \\(\\t{\\sigma }\\) gegeben sind. Anmerkung: In der Einsteinschen Summenkonvention lässt man Summationssymbole weg und impliziert Summation über wiederholte Indices. Im obigen Beispiel, \\begin{equation} \\partial _i \\sigma _{ij} \\equiv \\sum _i \\partial _i \\sigma _{ij}. \\end{equation} Ein Skalarprodukt zwischen den Vektoren \\(\\v{a}\\) und \\(\\v{b}\\) wird in dieser Konvention geschrieben als \\begin{equation} \\v{a}\\cdot \\v{b} = a_i b_i. \\end{equation} Diese Indexschreibweise ist nützlich, weil sie eindeutig ist. In der dyadischen Notation müssen wir meistens dazu sagen, was wir mit einer Operation meinen. So ist z.B. bei der Divergenz eines Tensors nicht klar, ob die Divergenz auf den ersten oder den zweiten Index wirken soll. (Wir nutzen hier eine Konvention, in der die Divergenz auf den ersten Index wirkt.) . 15.2 Hooksche Gesetz . Neben dem physikalischen Grundprinzip, dass die Erhaltung des Impulsstromes und damit das elastostatische Gleichgewicht beschreibt, brauchen wir noch ein Konstitutivgesetz, dass uns sagt wie der Spannungstensor (also der Impulsstrom) auszusehen hat. Hierzu führen wir zunächst die Verschiebungen \\(\\v{u}(\\v{r})\\) ein, die die Verformung eines Raumpunktes auf Grund der mechanischen Belastung beschrieben. Aus diesen Verschieben berechnen wir den Dehnungstensor \\begin{equation} \\t{\\varepsilon } = \\frac{1}{2}\\left [ \\nabla \\v{u} + \\left (\\nabla \\v{u}\\right )^T \\right ], \\label{eq:strain} \\end{equation} bzw. in Komponentenschreibweise \\begin{equation} \\varepsilon _{ij} = \\frac{1}{2} \\left ( \\partial _i u_j + \\partial _j u_i \\right ). \\end{equation} . Anmerkung: Der Ausdruck \\(\\nabla \\v{u}\\) ist nicht die Divergenz von \\(\\v{u}\\). Diese ist gegeben durch \\(\\nabla \\cdot \\v{u}\\) – der Punkt ist entscheidend. \\(\\nabla \\v{u}\\) ist der Gradient des Vektorfeldes \\(\\v{u}(\\v{r})\\) und damit ein Tensorfeld zweiter Ordnung. Die Komponenten sind gegeben durch \\begin{equation} \\left [\\nabla \\v{u}\\right ]_{ij} = \\partial _i u_j. \\end{equation} Die Komponenten des transponierten Tensors sind daher \\begin{equation} \\left [\\nabla \\v{u}\\right ]^T_{ij} = \\left [\\nabla \\v{u}\\right ]_{ji} = \\partial _j u_i. \\end{equation} . Das Hooksche Gesetz beschreibt nun welche Dehnung zu welcher Spannung führt. Für isotrope Festkörper lautet es \\begin{equation} \\t{\\sigma } = \\left (\\lambda \\, \\text{tr}\\,\\t{\\varepsilon }'\\right ) \\t{1} + 2\\mu \\t{\\varepsilon }' \\quad \\text{bzw.}\\quad \\sigma _{ij} = \\lambda \\delta _{ij} \\varepsilon '_{kk} + 2\\mu \\varepsilon '_{ij}. \\label{eq:Hookes-law} \\end{equation} mit \\(\\varepsilon _{ij}'=\\varepsilon _{ij}-\\varepsilon _{0,ij}\\). Hierbei heißen \\(\\lambda \\) und \\(\\mu \\) Lamé-Konstanten. Die Konstante \\(\\mu \\) wird auch das Schermodul genannt. Der Ausdruck \\(\\varepsilon _{kk}'\\equiv \\sum _k\\varepsilon _{kk}'=\\text{tr}\\,\\t{\\varepsilon }'\\) (Einstein-Konvention!) ist die Spur des Dehnungstensors. Wir haben hier den Dehnungstensor \\(\\t{\\varepsilon }'=\\t{\\varepsilon }-\\t{\\varepsilon }_0\\) eingeführt, der eine Eigendehnung \\(\\v{\\varepsilon }_0\\) (engl. “eigenstrain”) berücksichtig, die z.B. durch eine thermische Expansion gegeben sein kann. 15.3 Schwache Form . Wir haben ein gekoppeltes lineares Gleichungssystem zweiter Ordnung, welches wir nun mit Hilfe der Methode der finiten Elemente diskretisieren werden. Wir formulieren zunächst die schwache Form von Gl. \\eqref{eq:elastostaticeq}, \\begin{equation} \\int \\dif ^3 r\\, \\v{v}(\\v{r})\\cdot \\left ( \\nabla \\cdot \\t{\\sigma } \\right ) = 0 \\quad \\text{bzw.}\\quad \\int \\dif ^3 r\\, v_j(\\v{r}) \\partial _i\\sigma _{ij} = 0, \\end{equation} wobei \\(\\v{v}(\\v{r})\\) nun ein Testvektor ist. Wir nutzen nun wieder eine Variante der Produktregel, \\begin{equation} \\partial _i\\left ( \\sigma _{ij} v_j \\right ) = \\left (\\partial _i \\sigma _{ij}\\right ) v_j + \\sigma _{ij} \\left (\\partial _i v_j\\right ), \\end{equation} um die Ableitung auf die Testfunktion zu überführen. Man erhält \\begin{equation} \\int \\dif ^3 r\\, \\left [\\nabla \\cdot \\left (\\t{\\sigma }\\cdot \\v{v}\\right ) - \\left (\\nabla \\v{v}\\right ):\\t{\\sigma } \\right ] = 0, \\label{eq:weakmech1} \\end{equation} wobei der Doppelpunkt ein doppeltes Skalarprodukt (oder Kontraktion) bezeichnet, \\(\\t{A}:\\t{B}=A_{ij}B_{ij}\\). Wir können nun wieder den ersten Term in Gl. \\eqref{eq:weakmech1} mit Hilfe des Gaussschen Satzes in ein Oberflächenintegral, \\begin{equation} \\int \\dif ^2 r\\, \\v{v}\\cdot \\left (\\t{\\sigma }\\cdot \\hat{n}\\right ) - \\int \\dif ^3 r\\, \\left (\\nabla \\v{v}\\right ):\\t{\\sigma } = 0, \\label{eq:weakmech2} \\end{equation} überführen, wobei die Tatsache genutzt wurde, dass \\(\\t{\\sigma }\\) symmetrisch ist. Dies ist die schwache Form des mechanischen Gleichgewichts. Der Ausdruck \\(\\t{\\sigma }\\cdot \\hat{n}\\) sind die die Flächenlasten (engl. “tractions”) auf die Oberfläche. 15.4 Diskretisierung . Wir diskretisieren diese Gleichung nun mit Hilfe der Galerkin-Methode und setzen gleich lineare finite Elemente als Basisfunktionen an. Dies erlaubt es uns, die Diskretisierung direkt mit Hilfe der Formfunktionen und nicht der Basisfunktionen zu schreiben. Wir setzen also innerhalb Element \\((n)\\) an, dass \\begin{equation} u_j(\\v{r}) = a_{j,Jn} N_J^{(n)}(\\v{r}), \\end{equation} wobei \\(Jn\\) für den globalen Knotenindex steht, der dem lokalen Index des Knotens \\(J\\) auf Element \\((n)\\) entspricht und Summation über \\(J\\) auf Grund des wiederholten Indices impliziert ist. Unsere Testfunktion \\(\\v{v}(\\v{r})\\) ist nun vektorwertig. Wir benötigen damit einen Satz von \\(DN\\) Testvektoren, wobei \\(D\\) die Dimension des Raumes und \\(N\\) die Anzahl der Elemente bezeichnet. Wir setzen daher innerhalb des Elements \\((n)\\) \\begin{equation} \\v{v}_{i,I}(\\v{r}) = N_I^{(n)}(\\v{r}) \\hat{e}_i \\end{equation} mit \\(i\\in [1,\\ldots ,D]\\) als Testvektor an. Hier bezeichnet \\(\\hat{e}_i\\) den Vektor, bei dem die \\(i\\)-te Komponente \\(1\\) und alle anderen Komponenten \\(0\\) sind, also den kanonischen Einheitsvektor in Richtung \\(i\\). Mit diesen Ansatzfunktionen erhält man für die Dehnung auf Element \\((n)\\) \\begin{equation} \\varepsilon ^{(n)}_{ij} = \\frac{1}{2} \\left (a_{i,Jn} \\partial _j N_J^{(n)} + a_{j,Jn} \\partial _i N_J^{(n)}\\right ). \\end{equation} Das Hooksche Gesetz wird damit zu \\begin{equation} \\sigma ^{(n)}_{ij}(\\v{r}) = \\lambda (\\v{r}) \\delta _{ij} a_{k,Jn} \\partial _k N_J^{(n)} + \\mu (\\v{r}) \\left (a_{i,Jn} \\partial _j N_J^{(n)} + a_{j,Jn} \\partial _i N_J^{(n)}\\right ) - \\sigma _{0,ij}(\\v{r}) \\end{equation} mit \\begin{equation} \\sigma _{0,ij}(\\v{r}) = \\lambda (\\v{r}) \\delta _{ij} \\varepsilon _{0,kk}(\\v{r}) + 2\\mu (\\v{r}) \\varepsilon _{0,ij}(\\v{r}). \\end{equation} Die diskretisierte Form des Volumenterms der Gleichgewichtsbedingung lautet \\begin{equation} \\begin{split} \\int \\dif ^3 r\\, \\left (\\nabla \\v{v}\\right ):\\t{\\sigma } =&amp; \\int \\dif ^3 r\\, \\left (\\nabla N_I^{(n)}\\otimes \\hat{e}_i\\right ):\\t{\\sigma } \\\\ =&amp; \\int \\dif ^3 r\\, \\left (\\partial _j N_I^{(n)}\\right )\\sigma _{ji} \\\\ =&amp; \\int \\dif ^3 r\\, \\left \\{ \\lambda (\\v{r}) a_{k,Jn} \\partial _i N_I^{(n)} \\partial _k N_J^{(n)}\\right . \\\\ &amp; + \\mu (\\v{r}) \\left (a_{i,Jn} \\partial _j N_I^{(n)}\\partial _j N_J^{(n)} + a_{j,Jn} \\partial _j N_I^{(n)}\\partial _i N_J^{(n)}\\right ) \\\\ &amp;\\left . - \\sigma _{0,ji}(\\v{r}) \\partial _j N_I^{(n)} \\right \\}.\\\\ \\end{split} \\label{eq:voleq} \\end{equation} Für lineare Element sind bis auf die Materialkonstanten alle Terme in dieser Gleichung konstant. Das Integral führt damit effektiv zu einer Mittelung der Materialkonstanten auf den Element. Wir führen die mittleren Materialkonstanten \\begin{equation} \\lambda ^{(n)} = \\frac{1}{V^{(n)}} \\int \\dif ^3 r\\, \\lambda (\\v{r}) \\end{equation} und eine äquivalent Gleichung für \\(\\mu \\) und \\(\\t{\\sigma }_0\\) ein. Hierbei ist nun \\(V^{(n)}\\) das Volumen des Elements \\((n)\\). Wir können Gl. \\eqref{eq:voleq} schreiben als \\begin{equation} \\begin{split} \\int \\dif ^3 r\\, \\left (\\nabla \\v{v}\\right ):\\t{\\sigma } =&amp; \\lambda ^{(n)} a_{j,Jn}V^{(n)}\\partial _i N_I^{(n)} \\partial _j N_J^{(n)} + \\mu ^{(n)} a_{j,Jn} \\delta _{ij} V^{(n)}\\partial _k N_I^{(n)}\\partial _k N_J^{(n)} \\\\ &amp; + \\mu ^{(n)} a_{j,Jn} V^{(n)}\\partial _j N_I^{(n)}\\partial _i N_J^{(n)} - V^{(n)}\\sigma _{0,ij}^{(n)} \\partial _j N_I^{(n)}. \\end{split} \\end{equation} Die Elementmatrix hat daher die Komponenten \\begin{equation} K^{(n)}_{IiJj} = \\lambda ^{(n)} k_{IiJj}^{(n)} + \\mu ^{(n)} \\delta _{ij} k_{IkJk}^{(n)} + \\mu ^{(n)} k_{IjJi}^{(n)} \\end{equation} mit \\(k_{IiJj}^{(n)}=V^{(n)}\\partial _i N_I^{(n)} \\partial _j N_J^{(n)}\\) und der Beitrag des Elements zum Lastvektor lautet \\(f_{Ii}^{(n)}=V^{(n)}\\sigma _{0,ij}^{(n)} \\partial _j N_I^{(n)}\\). Anmerkung: Für unser strukturiertes zweidimensionales Gitter erhalten wir \\(V^{(n)}=\\Delta x\\Delta y/2\\) und \\begin{equation} \\t{k} = \\frac{1}{2} \\begin{pmatrix} \\Delta y/\\Delta x &amp; 1 &amp; -\\Delta y/\\Delta x &amp; \\cdot &amp; \\cdot &amp; -1 \\\\ 1 &amp; \\Delta x/\\Delta y &amp; -1 &amp; \\cdot &amp; \\cdot &amp; -\\Delta x/\\Delta y \\\\ -\\Delta y/\\Delta x &amp; -1 &amp; \\Delta y/\\Delta x &amp; \\cdot &amp; \\cdot &amp; 1 \\\\ \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ -1 &amp; -\\Delta x/\\Delta y &amp; 1 &amp; \\cdot &amp; \\cdot &amp; \\Delta x/\\Delta y \\end{pmatrix} \\end{equation} sowohl für das untere linke als auch das obere rechte Dreieck. Der Lastvektor wird zu \\begin{equation} \\v{f} = \\frac{1}{2}\\begin{pmatrix} -\\sigma _{0,xx}\\Delta y -\\sigma _{0,xy}\\Delta x \\\\ -\\sigma _{0,xy}\\Delta y -\\sigma _{0,yy}\\Delta x \\\\ \\sigma _{0,xx}\\Delta y \\\\ \\sigma _{0,xy}\\Delta y \\\\ \\sigma _{0,xy}\\Delta x \\\\ \\sigma _{0,yy}\\Delta x \\end{pmatrix} \\end{equation} für das untere linke Dreieck. Der Lastvektor für das obere rechte Dreieck ist \\(-\\v{f}\\). Für \\(\\Delta x=\\Delta y\\) wird die Elementsteifigkeitsmatrix zu \\begin{equation} \\t{k} = \\frac{1}{2} \\begin{pmatrix} 1 &amp; 1 &amp; -1 &amp; \\cdot &amp; \\cdot &amp; -1 \\\\ 1 &amp; 1 &amp; -1 &amp; \\cdot &amp; \\cdot &amp; -1 \\\\ -1 &amp; -1 &amp; 1 &amp; \\cdot &amp; \\cdot &amp; 1 \\\\ \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ -1 &amp; -1 &amp; 1 &amp; \\cdot &amp; \\cdot &amp; 1 \\end{pmatrix}. \\end{equation} Wenn wir hier die Spur von Untermatrizen der Größe \\(2\\times 2\\) berechnen, erhalten wir die Matrix des Laplace-Operators, Gl. \\eqref{eq:elmat2d}. Die Dehnung auf Element \\((n)\\) wird zu \\begin{align} \\varepsilon ^{(n)}_{xx} &amp;= a_{x,Jn} \\partial _x N_J^{(n)} = -a_{x,0n}/\\Delta x + a_{x,1n}/\\Delta x \\\\ \\varepsilon ^{(n)}_{yy} &amp;= a_{y,Jn} \\partial _y N_J^{(n)} = -a_{y,0n}/\\Delta _y + a_{y,2n}/\\Delta y \\\\ \\varepsilon ^{(n)}_{xy} &amp;= \\frac{1}{2} \\left (a_{x,Jn} \\partial _y N_J^{(n)} + a_{y,Jn} \\partial _x N_J^{(n)}\\right ) \\nonumber \\\\ &amp;= \\frac{1}{2}\\left (-a_{x,0n}/\\Delta y + a_{x,2n}/\\Delta y - a_{y,0n}/\\Delta x + a_{y,1n}/\\Delta x\\right )t \\end{align} . ",
    "url": "http://localhost:4000/_lecture/chapter15.html#x1-100015",
    "relUrl": "/_lecture/chapter15.html#x1-100015"
  },"43": {
    "doc": "Kapitel 15",
    "title": "Literaturverzeichnis",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter15.html#x1-600015.4",
    "relUrl": "/_lecture/chapter15.html#x1-600015.4"
  },"44": {
    "doc": "Kapitel 15",
    "title": "Kapitel 15",
    "content": " ",
    "url": "http://localhost:4000/_lecture/chapter15.html",
    "relUrl": "/_lecture/chapter15.html"
  },"45": {
    "doc": "Impressum",
    "title": "Angaben gemäß § 5 TMG",
    "content": " ",
    "url": "http://localhost:4000/impressum.html#angaben-gem%C3%A4%C3%9F--5-tmg",
    "relUrl": "/impressum.html#angaben-gemäß--5-tmg"
  },"46": {
    "doc": "Impressum",
    "title": "Verantwortlich für den Inhalt nach § 55 Abs. 2 RStV",
    "content": "Prof. Dr. Lars Pastewka Albert-Ludwigs-Universität IMTEK - Institut für Mikrosystemtechnik Professur für Simulation Georges-Koehler-Allee 103, 3. OG 79110 Freiburg . ",
    "url": "http://localhost:4000/impressum.html#verantwortlich-f%C3%BCr-den-inhalt-nach--55-abs-2-rstv",
    "relUrl": "/impressum.html#verantwortlich-für-den-inhalt-nach--55-abs-2-rstv"
  },"47": {
    "doc": "Impressum",
    "title": "Kontakt",
    "content": "Telefon: +49 761 203 67480 E-Mail: lars.pastewka@imtek.uni-freiburg.de . ",
    "url": "http://localhost:4000/impressum.html#kontakt",
    "relUrl": "/impressum.html#kontakt"
  },"48": {
    "doc": "Impressum",
    "title": "Datenschutzerklärung (DSGVO)",
    "content": "Auf dieser Webseite werden keine personenbezogenen Daten erhoben, gespeichert oder verarbeitet. Es werden keine Cookies verwendet. Diese Website wird auf GitHub als GitHub Pages gehostet. ",
    "url": "http://localhost:4000/impressum.html#datenschutzerkl%C3%A4rung-dsgvo",
    "relUrl": "/impressum.html#datenschutzerklärung-dsgvo"
  },"49": {
    "doc": "Impressum",
    "title": "Impressum",
    "content": " ",
    "url": "http://localhost:4000/impressum.html",
    "relUrl": "/impressum.html"
  },"50": {
    "doc": "Problem sets",
    "title": "Problem sets",
    "content": " ",
    "url": "http://localhost:4000/_homework/",
    "relUrl": "/_homework/"
  },"51": {
    "doc": "Lecture",
    "title": "Lecture",
    "content": " ",
    "url": "http://localhost:4000/_lecture/",
    "relUrl": "/_lecture/"
  },"52": {
    "doc": "Lecture",
    "title": "Learning material",
    "content": "Welcome to the lecture Micromechanics. You can find here learning material specifically targeted for this class. The goal of the material is to prepare you for the solution of the problem sets and the final exam. You should also use other source of information, e.g. book. Wikipedia also contains useful information on the subject matter of this class. We provide two kinds of learning material: . | Lecture videos | Written text, that you can download here as a single PDF file | . The material is structured along weeks to define a pace with which you should study the material. You can of course also go through the material faster, but please try to keep up and not fall behind the schedule. ",
    "url": "http://localhost:4000/_lecture/#learning-material",
    "relUrl": "/_lecture/#learning-material"
  },"53": {
    "doc": "Lecture",
    "title": "Contents",
    "content": "This class teaches the following subjects: . | Static equilibrium of beam systems | Elastostatic equilibrium | Elastic equilibrium of beams and plates | Plastic and brittle failure | . Please talk to us if aspects of this material are unclear or wrong. We do make mistakes; please contact us immediately in the case that you discover something that is wrong with the material. Please leave a comment on the issue tracker on Github. ",
    "url": "http://localhost:4000/_lecture/#contents",
    "relUrl": "/_lecture/#contents"
  },"54": {
    "doc": "Milestone 01",
    "title": "Milestone 1  Setting up the build environment",
    "content": " ",
    "url": "http://localhost:4000/_homework/uebungsblatt01.html#milestone-1--setting-up-the-build-environment",
    "relUrl": "/_homework/uebungsblatt01.html#milestone-1--setting-up-the-build-environment"
  },"55": {
    "doc": "Milestone 01",
    "title": "Learning goals",
    "content": "The student will… . | …be able to compile a C++ project with CMake. | . ",
    "url": "http://localhost:4000/_homework/uebungsblatt01.html#learning-goals",
    "relUrl": "/_homework/uebungsblatt01.html#learning-goals"
  },"56": {
    "doc": "Milestone 01",
    "title": "Introduction",
    "content": "In this first milestone we will set up a build environemnt and make sure that you can compile C++ code on your computer. This will be the starting point for the developments in the following milestones. ",
    "url": "http://localhost:4000/_homework/uebungsblatt01.html#introduction",
    "relUrl": "/_homework/uebungsblatt01.html#introduction"
  },"57": {
    "doc": "Milestone 01",
    "title": "Setting up your system",
    "content": "The starting point of your project is setting up a proper build environment. This means, you need to install and test all tools necessary for the project. In particular, you will need: . | A C++ compiler | CMake (at least version 3.11) for our build environment | An MPI installation | . We provide installation instructions for Ubuntu installations. If you have a Windows machine, we recommend to use the Windows Subsystem for Linux (WSL). Documentation on how to install WSL on Windows 10 can be found here. The following instructions also apply for Ubuntu installed within WSL. Once you have these things set up, open a command shell and type . sudo apt-get update sudo apt-get install cmake gcc clang gdb build-essential git cmake-curses-gui valgrind sudo apt-get install openmpi-bin libopenmpi-dev . Note that if you are on a different system than Ubuntu, these commands may differ. On Ubuntu/Debian it is apt or apt-get but on Fedora/CentOS/RHEL the package manager command is dnf. On macOS it depends on which package manager you have installed, the most popular one is Homebrew which provides the brew command for package installation. The names of the packages will also vary between these systems. We recommend using a development environment for developing code. We ourselves use CLion. Free educational licenses for CLion can be obtained here. CLion is available for all of the above platforms and can on Windows be configured to use WSL. (Documentation on CLion and WSL can be found here.) . ",
    "url": "http://localhost:4000/_homework/uebungsblatt01.html#setting-up-your-system",
    "relUrl": "/_homework/uebungsblatt01.html#setting-up-your-system"
  },"58": {
    "doc": "Milestone 01",
    "title": "Creating an empty repository",
    "content": "The first thing you need to do is to set up your build environment. We have done this for you and provide a template repository here: https://github.com/imtek-simulation/cmake-skeleton/. We will now be walking you through the process of obtaining this skeleton repository from the command line. You can also carry out the whole process within CLion. On Github, you can simply create a new repository from our template. Navigate to the link above and click on “Use this template”. You will be asked for a new name of the repository: Let’s call this yamd (Yet Another Molecular Dynamics code). Since my username is “pastewka”, the repository now resides under . https://github.com/pastewka/yamd . You can now check this repository out, i.e. copy it to your local machine. On the shell, type . git clone git@github.com:pastewka/yamd.git . (and replace “pastewka” and “yamd” with whatever is appropriate for you). The code now resides in the subdirectory “yamd”. Note that if you do not want to work on github, you can also directly check out the template repository. Our template repository has existing CMake files. Those CMake files are set up to automatically download the libraries . | Eigen for basic (array) data structures and | Googletest as a testing framework. | . We will work with these libraries throughout this class. Note: If you are unfamiliar with the unix shell, we recommend this tutorial. We also strongly recommend that you use version control (git). If you are unfamiliar with git and want to learn more, see this tutorial. Compiling the code . The template repository contains a file main.cpp that prints the string “Hello world!” to screen and a simple test test_hello_world.cpp. We need to instruct CMake to create what is called a Makefile that contains instructions how to build the code. CMake generally builds the code in a directory that is separate from the source directory. This is different from other build systems. We recommend that you create a directory build inside your source directory. First, navigate to the source code and create this directory: . cd yamd mkdir build cd build . Now, create the makefiles: . cmake .. The argument to cmake tells it where the source code is located, here in the directory level just upwards of the current one (i.e. in ..). You can also build in any other directory but then need to specify the appropriate path when running cmake. Note that cmake has lots of configuration options. To see those, run the text-based user interface: . ccmake .. The additional c in front stands for curses, the library that is used to create the text-based user interface. You can now execute . make . to compile the code. Now run ./myproject tests/myproject_tests . If this worked, you have successfully compiled the hello world program and its tests. ",
    "url": "http://localhost:4000/_homework/uebungsblatt01.html#creating-an-empty-repository",
    "relUrl": "/_homework/uebungsblatt01.html#creating-an-empty-repository"
  },"59": {
    "doc": "Milestone 01",
    "title": "Task summary",
    "content": "This milestone requires the following tasks: . | Create a repository for your code development from our template | Compile the template and run main exectuable and tests | . We provide the following files for you: . | Skeleton repository at https://github.com/imtek-simulation/cmake-skeleton/ | . ",
    "url": "http://localhost:4000/_homework/uebungsblatt01.html#task-summary",
    "relUrl": "/_homework/uebungsblatt01.html#task-summary"
  },"60": {
    "doc": "Milestone 01",
    "title": "Milestone 01",
    "content": " ",
    "url": "http://localhost:4000/_homework/uebungsblatt01.html",
    "relUrl": "/_homework/uebungsblatt01.html"
  },"61": {
    "doc": "Milestone 02",
    "title": "Milestone 2  Velocity-Verlet integration for a single atom",
    "content": " ",
    "url": "http://localhost:4000/_homework/uebungsblatt02.html#milestone-2--velocity-verlet-integration-for-a-single-atom",
    "relUrl": "/_homework/uebungsblatt02.html#milestone-2--velocity-verlet-integration-for-a-single-atom"
  },"62": {
    "doc": "Milestone 02",
    "title": "Learning goals",
    "content": "The student will… . | …understand how to work with source and header files. | …learn how to add new tests to the testing framework. | . ",
    "url": "http://localhost:4000/_homework/uebungsblatt02.html#learning-goals",
    "relUrl": "/_homework/uebungsblatt02.html#learning-goals"
  },"63": {
    "doc": "Milestone 02",
    "title": "Introduction",
    "content": "In this second milestone you will implement a Velocity-Verlet integrator. You will learn about header and source files and how to add them to the CMake build system. You will also need to think about testing, i.e. how to systematically test an implementation. Testing makes sure your new function works correctly but it also makes sure that you will notice when you break it in the future. Note that we explain only the very basics of the relevant C++ features here but link to more detailed explanation. ",
    "url": "http://localhost:4000/_homework/uebungsblatt02.html#introduction",
    "relUrl": "/_homework/uebungsblatt02.html#introduction"
  },"64": {
    "doc": "Milestone 02",
    "title": "Adding a header/source file",
    "content": "We recommend to add the integration functionality into a new module that consists of a header and source file. The header file typically has the extension .h and contains only the signatures (also called interfaces) of the functions. It is required such that the module can be used from another source file. Create a file verlet.h with the following contents: . #ifndef __VERLET_H #define __VERLET_H void verlet_step1(double &amp;x, double &amp;y, double &amp;z, double &amp;vx, double &amp;vy, double &amp;vz, double fx, double fy, double fz, double timestep); void verlet_step2(double &amp;vx, double &amp;vy, double &amp;vz, double fx, double fy, double fz, double timestep); #endif // __VERLET_H . The #ifndef __VERLET_H commands are called a header guard and avoid double inclusion of the file (e.g. in a chain of include statements). Everything that starts with a # is processed by the preprocessor which produces the file that is actually compiled by the C++ compiler. The &amp; symbol in the function signature is a reference. It tells the compiler to pass only the memory location of the underlying data rather than copying it. It should be used for large compound types. (Passing integers or double floating point numbers without reference is fine.) Note that arguments passed as a reference can be modified inside the function, which is why we can update positions and velocities inside verlet_step1. The corresponding source file verlet.cpp should look like this: . #include \"verlet.h\" void verlet_step1(double &amp;x, double &amp;y, double &amp;z, double &amp;vx, double &amp;vy, double &amp;vz, double fx, double fy, double fz, double timestep) { ... implement Verlet step1 here ... } void verlet_step2(double &amp;vx, double &amp;vy, double &amp;vz, double fx, double fy, double fz, double timestep) { ... implement Verlet step2 here ... } . Header and source files have typically extensions .h and .cpp. On Unix system, you sometimes find .hh and .cc for C++ code. C++ headers sometimes have the suffix .hpp. To compile the code, you need to add headers files to MYPROJECT_HDRS and sources files to MYPROJECT_SRCS in the main CMakeLists.txt. From the command-line, you can compile the code by running make in the build directory. ",
    "url": "http://localhost:4000/_homework/uebungsblatt02.html#adding-a-headersource-file",
    "relUrl": "/_homework/uebungsblatt02.html#adding-a-headersource-file"
  },"65": {
    "doc": "Milestone 02",
    "title": "Adding new test cases",
    "content": "It is important to properly test any implementation. You can even adopt a test-driven development style in which tests are written before the implementation. We also here encourage you to write tests for all parts of your molecular dynamics code. We will outline possible testing strategies in the respective milestones. One possible test strategy for numerical code is to compare a numerical solution against a known analytical solution. We are here solving Newton’s equation of motion. A possible analytical solution would be the motion of an atom under a constant force, since this is straightforward to solve. To add a new test, create a new file to the tests subdirectory and add it to the myproject_tests_SRCS in CMakeLists.txt in the tests directory. You can copy the file test_hello_world.cpp as a template. The project uses Googletest. Please browse the documentation and look at the primer on the documentation page. A test case consists of a number of assertion. An assertion defines a certain outcome of the function to be tested. As an example, let us assume we were writing a test for a \\(sin\\) function. We know for example than the function vanishes at integer multiples of \\(\\pi\\). A test case could look like this: . TEST(SinTest, IntegerMultiplesOfPi) { EXPECT_EQ(sin(0), 0); EXPECT_EQ(sin(pi), 0); EXPECT_EQ(sin(2+pi), 0); } . Note that instead of EXCEPT_EQ you can use ASSERT_EQ, which terminates the test at the first failure. Note that a proper test for the \\(sin\\) function would also need to test intermediate values. Tests for floating-point number should not be done using equalities as in the above example. This is because floating-point results are subject to rounding errors. More complex numerical schemes (such as the integrator discussed in the next milestone) are additionally subject to numerical (discretization) errors. Any comparison must therefore be carried out with a certain tolerance. Googletest provides the assertion EXPECT_NEAR and ASSERT_NEAR for this. These assertions take a third argument that specifies the maximum tolerable absolute difference between the two arguments: . TEST(SinTest, IntegerMultiplesOfPi) { EXPECT_NEAR(sin(0), 0, 1e-6); EXPECT_NEAR(sin(pi), 0, 1e-6); EXPECT_NEAR(sin(2+pi), 0, 1e-6); } . ",
    "url": "http://localhost:4000/_homework/uebungsblatt02.html#adding-new-test-cases",
    "relUrl": "/_homework/uebungsblatt02.html#adding-new-test-cases"
  },"66": {
    "doc": "Milestone 02",
    "title": "Implement integrator and tests",
    "content": "Implement the Velocity-Verlet integration and write a test for it by comparing the motion of a single atom under the action of a constant force. You will find useful code snippets in the lecture material. Note that the test will require a first mini-(molecular)-dynamics simulation. In order to integrate the equations of motion, you will need to write a loop of the form . for (int i = 0; i &lt; nb_steps; ++i) { std::cout &lt;&lt; \"Step: \" &lt;&lt; i &lt;&lt; std::endl; verlet_step1(args...); ... compute forces here ... verlet_step2(args...); } . This loop integrates the equation of motion for nb_steps steps. The main loop of any molecular dynamics simulation code looks like this. We will add bells and whistles to it, but the main structure will remain the same. The stream std::cout can be used to print something to the screen. You can find the documentation for iostream here. ",
    "url": "http://localhost:4000/_homework/uebungsblatt02.html#implement-integrator-and-tests",
    "relUrl": "/_homework/uebungsblatt02.html#implement-integrator-and-tests"
  },"67": {
    "doc": "Milestone 02",
    "title": "Task summary",
    "content": "This milestone requires the following tasks: . | Implement the Velocity-Verlet integrator | Implement a test for the Velocity-Verlet integrator | . ",
    "url": "http://localhost:4000/_homework/uebungsblatt02.html#task-summary",
    "relUrl": "/_homework/uebungsblatt02.html#task-summary"
  },"68": {
    "doc": "Milestone 02",
    "title": "Milestone 02",
    "content": " ",
    "url": "http://localhost:4000/_homework/uebungsblatt02.html",
    "relUrl": "/_homework/uebungsblatt02.html"
  },"69": {
    "doc": "Milestone 03",
    "title": "Milestone 3  Velocity-Verlet integration for multiple atoms",
    "content": " ",
    "url": "http://localhost:4000/_homework/uebungsblatt03.html#milestone-3--velocity-verlet-integration-for-multiple-atoms",
    "relUrl": "/_homework/uebungsblatt03.html#milestone-3--velocity-verlet-integration-for-multiple-atoms"
  },"70": {
    "doc": "Milestone 03",
    "title": "Learning goals",
    "content": "The student will… . | …learn how to work with Eigen arrays. | . ",
    "url": "http://localhost:4000/_homework/uebungsblatt03.html#learning-goals",
    "relUrl": "/_homework/uebungsblatt03.html#learning-goals"
  },"71": {
    "doc": "Milestone 03",
    "title": "Introduction",
    "content": "The implementation of the integration algorithm from Milestone 2 only works for a single atom. You will now extend the function verlet_step1 and verlet_step2 to work with multiple atoms. For this we will have to introduce data structure that can store the positions and velocities of multiple atoms. We will use Eigen arrays for this. ",
    "url": "http://localhost:4000/_homework/uebungsblatt03.html#introduction",
    "relUrl": "/_homework/uebungsblatt03.html#introduction"
  },"72": {
    "doc": "Milestone 03",
    "title": "Basic data structures",
    "content": "Arrays store multiple values of the same data type and can be used to represent, for example, positions of all atoms. Arrays are indexed and can be though of as the realization of the mathematical objects that are vectors, matrices or tensors. We would like to emphasize, that choosing the right data structures is the single most important part for obtaining code that performs well. As a general rule, the data structure should be designed in a way that data that is processed consecutively is also stored in memory in a continuous manner. This ensures cache coherence. For example, we could be tempted to create a class Atom that contains the positions, velocities, etc. of a single atom and than use an array (e.g. std::vector&lt;Atom&gt; atoms) of that class as the basic data structure. However, positions are then no longer consecutive in memory, since the Atom class contains velocities, possible forces, maybe charges and other properties. A function (e.g. computing forces) does not need the velocities would still load them into the cache, as the cache line size for all modern CPUs is bytes. For high-performance numerical code, it is therefore always preferable to use structures of arrays rather than arrays of structure. In order to store the positions, we will use an Eigen array of shape \\(3\\times N\\) where \\(N\\) is the total number of atoms in our system. You can define an alias to that type with the using keyword: . using Positions_t = Eigen::Array3Xd; . We recommend defining similar aliases for the velocities, forces etc., even if they point to the same type. This enhances readability. Place those type aliases in a separate header file, e.g. types.h. Eigen::Array3Xd is a pre-defined array type that stores doubles (hence the suffix d), has \\(3\\) rows (this is fixed at compile time) and a dynamic number of columns (indicated by the X). Eigen arrays are stored column major, hence the \\(3\\) row entries are stored consecutive in memory. Note that Eigen only supports \\(1\\)- and \\(2\\)-dimensional arrays. ",
    "url": "http://localhost:4000/_homework/uebungsblatt03.html#basic-data-structures",
    "relUrl": "/_homework/uebungsblatt03.html#basic-data-structures"
  },"73": {
    "doc": "Milestone 03",
    "title": "Working with Eigen arrays",
    "content": "We will here outline a couple of important features of Eigen arrays. First, when initializing an array you need to specify the array size: . int nb_atoms = 10; Positions_t positions(3, nb_atoms); . Note that the number of rows (the first argument) is fixed but we still need to provide it upon initialization. The second argument nb_atoms is variable. This combination of fixed-variable sizes is indicated by the 3X suffix of the array type used here to store the positions. You can access values of the array using parenthesis, e.g. positions(2, 1) = 1.0; . sets the \\(y\\)-component of the position of the second atom to \\(1\\). (Important: Indices start at \\(0\\)!) If you want to access the \\(3\\)-vector containing all positions of the second atom, you can use . auto pos2{positions.col(1)}; . This yields column with index \\(1\\), but each column stores the three Cartesian components of the position in our case. You can for example compute the distance vector between two atoms \\(i\\) and \\(j\\) using . Eigen::Array3d distance_vector{positions.col(i) - positions.col(j)}; . Note that in the above example we have use the auto keyword to automatically derive the type, while in the second case we have explicitly used the data type Eigen::Array3d for the distance vector. The curly brackets are a non-narrowing initialization. This type of initialization avoids implicit type conversion and should be prefered over copy initialization or narrowing initialization (with round parenthesis). ",
    "url": "http://localhost:4000/_homework/uebungsblatt03.html#working-with-eigen-arrays",
    "relUrl": "/_homework/uebungsblatt03.html#working-with-eigen-arrays"
  },"74": {
    "doc": "Milestone 03",
    "title": "Integrator for multiple atoms",
    "content": "You are now in a position to turn your integrator into one that accepts multiple atoms. We suggest to use the following signature for the integrators: . #ifndef __VERLET_H #define __VERLET_H #include &lt;Eigen/Dense&gt; void verlet_step1(Eigen::Array3Xd &amp;positions, Eigen::Array3Xd &amp;velocities, const Eigen::Array3Xd &amp;forces, double timestep); void verlet_step2(Eigen::Array3Xd &amp;velocities, const Eigen::Array3Xd &amp;forces, double timestep); #endif // __VERLET_H . The const qualifier tells the compiler that a modification of that argument is not allowed, although it is passed as a reference. (We don’t need to modify the forces and it is good practice to protect the with this const qualifier to avoid accidental modification.) . The corresponding source file verlet.cpp should look like this: . #include \"verlet.h\" void verlet_step1(Eigen::Array3Xd &amp;positions, Eigen::Array3Xd &amp;velocities, const Eigen::Array3Xd &amp;forces, double timestep) { ... implement Verlet step1 here ... } void verlet_step2(Eigen::Array3Xd &amp;velocities, const Eigen::Array3Xd &amp;forces, double timestep) { ... implement Verlet step2 here ... } . Note that you only need to make minor modifications to your current, single-atom integrator, as the loop over atoms occurs automatically. For example, you can obtain an array containing all \\(x\\)-positions from positions.row(0). ",
    "url": "http://localhost:4000/_homework/uebungsblatt03.html#integrator-for-multiple-atoms",
    "relUrl": "/_homework/uebungsblatt03.html#integrator-for-multiple-atoms"
  },"75": {
    "doc": "Milestone 03",
    "title": "Testing the integrator",
    "content": "Update the tests such that they test your modified integrator. These tests should probably propagate a few atoms at the same time. ",
    "url": "http://localhost:4000/_homework/uebungsblatt03.html#testing-the-integrator",
    "relUrl": "/_homework/uebungsblatt03.html#testing-the-integrator"
  },"76": {
    "doc": "Milestone 03",
    "title": "Task summary",
    "content": "This milestone requires the following tasks: . | Extend your Velocity-Verlet integrator to work with multiple atoms | Update your tests to accomodate the changed interface | . ",
    "url": "http://localhost:4000/_homework/uebungsblatt03.html#task-summary",
    "relUrl": "/_homework/uebungsblatt03.html#task-summary"
  },"77": {
    "doc": "Milestone 03",
    "title": "Milestone 03",
    "content": " ",
    "url": "http://localhost:4000/_homework/uebungsblatt03.html",
    "relUrl": "/_homework/uebungsblatt03.html"
  },"78": {
    "doc": "Milestone 04",
    "title": "Milestone 4  Lennard-Jones potential with direct summation",
    "content": " ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html#milestone-4--lennard-jones-potential-with-direct-summation",
    "relUrl": "/_homework/uebungsblatt04.html#milestone-4--lennard-jones-potential-with-direct-summation"
  },"79": {
    "doc": "Milestone 04",
    "title": "Learning goals",
    "content": "The student will… . | …learn how to implement a simple interatomic potential. | …learn how to systematically test the implementation of this interatomic potential. | . ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html#learning-goals",
    "relUrl": "/_homework/uebungsblatt04.html#learning-goals"
  },"80": {
    "doc": "Milestone 04",
    "title": "Introduction",
    "content": "We will now implement our first interatomic potential: A Lennard-Jones interaction. The energy of a system interacting via Lennard-Jones forces is given by . \\[E_\\text{pot} = \\frac{1}{2} \\sum_{ij} 4 \\varepsilon \\left[ \\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^6\\right]\\] The term \\(\\propto r^{-12}\\) is a simple model for Pauli repulsion and the term \\(\\propto r^{-6}\\) is a model for London dispersion forces. Within this milestone, you will implement this potential via direct summation, i.e. directly using the equation given above without cutting it off at a certain distance. Note that it can be useful to create a separate build target with a separate main.cpp for this milestone. Our notes on CMake describe how to do that. ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html#introduction",
    "relUrl": "/_homework/uebungsblatt04.html#introduction"
  },"81": {
    "doc": "Milestone 04",
    "title": "A data structure for the atomic system",
    "content": "Before starting, we introduce a data structure that holds the information on the atomic system, i.e. the positions, velocities, forces etc. This makes it easier to pass the atomic system around. We suggest a data structure of the form: . using Positions_t = Eigen::Array3Xd; using Velocities_t = Eigen::Array3Xd; using Forces_t = Eigen::Array3Xd; class Atoms { public: Positions_t positions; Velocities_t velocities; Forces_t forces; Atoms(const Positions_t &amp;p) : positions{p}, velocities{3, p.cols()}, forces{3, p.cols()} { velocities.setZero(); forces.setZero(); } Atoms(const Positions_t &amp;p, const Velocities_t &amp;v) : positions{p}, velocities{v}, forces{3, p.cols()} { assert(p.cols() == v.cols()); forces.setZero(); } size_t nb_atoms() const { return positions.cols(); } }; . The const qualifier behind nb_atoms tells the compiler that this method does not change the state of the Atoms object, i.e. the value of positions, velocities and forces are not affected by a call to nb_atoms. Place this data structure in a separate header file, e.g. atoms.h. We had already discussed in [Milestone 3] that the types should reside in their own header, e.g. types.h. You can then simply include them in atoms.h by placing #include \"types.h\" somewhere at the beginning of the file. Make sure all header files have header guards. ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html#a-data-structure-for-the-atomic-system",
    "relUrl": "/_homework/uebungsblatt04.html#a-data-structure-for-the-atomic-system"
  },"82": {
    "doc": "Milestone 04",
    "title": "Signature of the function that computes the interatomic potential",
    "content": "Implement the Lennard-Jones potential. Note that you will need to derive the analytical gradient of the total energy . \\[\\vec{f}_k = \\nabla_k E\\] before you can implement the analytical forces. The final expression should take the form . \\[\\vec{f}_k = \\sum_i \\vec{f}_{ik}\\] where \\(\\vec{f}_{ik}\\) is a pair force. (You need to evaluate the specific expression for \\(\\vec{f}_{ik}\\) yourself.) This type of expression is most efficiently computed by looping over unique pairs. We suggest a function with the following signature: . double lj_direct_summation(Atoms &amp;atoms, double epsilon = 1.0, double sigma = 1.0); . This signature defines default parameters for epsilon and sigma, i.e. they need to be specified only if they differ from unity. The function directly modifies the forces in atoms.forces. The return value of this function is the potential energy. Place this function in its own source and header file, e.g. lj_direction_summation.h and lj_direct_summation.cpp. ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html#signature-of-the-function-that-computes-the-interatomic-potential",
    "relUrl": "/_homework/uebungsblatt04.html#signature-of-the-function-that-computes-the-interatomic-potential"
  },"83": {
    "doc": "Milestone 04",
    "title": "Testing the implementation",
    "content": "When implementing this function you will want to test that the forces that are computed are correct. In particular, the forces and energy need to be consistent in the sense that the forces are the negative derivative of the energy. The energy is typically easy to implement correctly, but forces can be fiddly. One sign of wrong forces is that energy in a molecular dynamics simulation is not conserved, but there are also other causes for this effect (e.g. a time step that is too large) which makes it difficult as a test for the implementation of forces. The common strategy is to compute the forces numerically from the energies. For this, we have to compute a numerical first derivative. This is straightforward to do from the difference quotient, e.g. \\[f'(x) \\approx \\frac{f(x+\\Delta x) - f(x-\\Delta x)}{2 \\Delta x}\\] A formal derivation of this expression can be obtained from a Taylor expansion of \\(f(x)\\). We can use this expression to compute numerical estimates of the forces. A test that uses this to test the analytical forces of the potential can be found here: test_lj_direct_summation.cpp. Place this file in your tests subdirectory and add it to the CMakeLists.txt to use it. Open it in an editor and try to understand how the test works. This type of test is often called a gradient test. ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html#testing-the-implementation",
    "relUrl": "/_homework/uebungsblatt04.html#testing-the-implementation"
  },"84": {
    "doc": "Milestone 04",
    "title": "A first molecular dynamics calculation",
    "content": "You are now in a position to run a first molecular dynamics calculation. To do this, you need a reasonable initial state for your simulation. The initial state is the initial condition for the solution of Newton’s equation of motion and requires you to specify positions and momenta. You can find such an initial state in the following file: lj54.xyz. The format of this file is called the XYZ file format. We provide a C++ module for reading and writing these files here: xyz.h, xyz.cpp. Include these files into your project. Also open them in an editor and try to understand what they do. You can then read an XYZ-file using the following code block: . #include \"xyz.h\" auto [names, positions, velocities]{read_xyz_with_velocities(\"lj54.xyz\")}; . The variable names contains the element names that you can discard at this point. Important are the variables positions and velocities that you should use as the initial state of your simulation. Note that the velocities contained in lj54.xyz are an extension to the typical XYZ file format that is, however, understood by common visualization tools. Update your code to read this file and then propagate the simulation for a total time of at least \\(100 \\sqrt{m\\sigma^2/\\varepsilon} \\). Use a mass of unity (\\(m=1)\\) and \\(\\varepsilon=1\\) and \\(\\sigma=1\\) for the Lennard-Jones interaction. A reasonable initial time step is \\( 0.001 \\sqrt{m\\sigma^2/\\varepsilon} \\). Monitor the total energy of your simulation. For this you need to implement the computation of the kinetic energy. At this point you can quantify the influence of the time step on your simulation. Change the time step and see how the total energy evolves. What is a good time step for your simulation? . ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html#a-first-molecular-dynamics-calculation",
    "relUrl": "/_homework/uebungsblatt04.html#a-first-molecular-dynamics-calculation"
  },"85": {
    "doc": "Milestone 04",
    "title": "Visualization",
    "content": "Since you have now run the first molecular dynamics calculation, it is useful to visualize your simulation, i.e. look at how the individual atoms move over time. To achieve this, output the state of the simulation as an XYZ at time intervals of order \\(1 \\sqrt{m\\sigma^2/\\varepsilon} \\). XYZ-files can be visualized with the Open Visualization Tool (OVITO). Download OVITO Basic, install it and look at one of your XYZ files. To output trajectories, you can do two things: . | Consecutively number your files, e.g. traj0000.xyz, traj0001.xyz, traj0002.xyz, etc., OVITO will automatically detect that this is a sequence of files (a trajectory) and allow you visualize the time evolution of your atomic configuration. | Write multiple XYZs into the same file. Also here OVITO will autodetect that this is a trajectory. The following code snippets where write_xyz can be repeated as often as necessary does this: | . std::ofstream traj(\"traj.xyz\"); ... write_xyz(traj, atoms); ... write_xyz(traj, atoms); ... traj.close(); . The second approach has the advantage that there is only a single file that you need to work with, but it can be difficult to extract individual frames from it (e.g. for restarts of your simulation). ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html#visualization",
    "relUrl": "/_homework/uebungsblatt04.html#visualization"
  },"86": {
    "doc": "Milestone 04",
    "title": "Task summary",
    "content": "This milestone requires the following tasks: . | Derive the analytical expression for the forces of the Lennard-Jones potential | Implement the Lennard-Jones potential and make sure the gradient test passes | Implement computation of the kinetic energy | Run a first molecular dynamics simulation | Decide on a “good” time step | Download and install OVITO | Visualize your simulation | . We ask you to provide the following analytical results in your final report: . | Derivation of the analytical expression for the forces of the Lennard-Jones potential | . We ask you to provide and discuss the following figures in your final report: . | Plot of the total energy as a function of time for different time steps | A sequence of snapshots (no more than 5) from your simulation run | . We provide the following files for you: . | lj54.xyz | test_lj_direct_summation.cpp | xyz.h | xyz.cpp | . ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html#task-summary",
    "relUrl": "/_homework/uebungsblatt04.html#task-summary"
  },"87": {
    "doc": "Milestone 04",
    "title": "Milestone 04",
    "content": " ",
    "url": "http://localhost:4000/_homework/uebungsblatt04.html",
    "relUrl": "/_homework/uebungsblatt04.html"
  }
}
